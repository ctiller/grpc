/*
 * Copyright 2017 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Automatically generated by tools/codegen/core/gen_settings_ids.py
 */

#include <grpc/support/port_platform.h>

#include "src/core/ext/transport/chttp2/transport/http2_settings.h"

namespace grpc_core {
Http2Settings::ParseResult Http2Settings::FromIncomingFrame(
    const Http2SettingsFrame& frame) const {
  Http2Settings settings(*this);
  for (const auto& setting : frame.settings) {
    switch (setting.id) {
      case 1:
        settings.SetHeaderTableSize(setting.value);
        break;
      case 2:
        if (setting.value < 0 || setting.value > 1) {
          return ParseError{GRPC_HTTP2_PROTOCOL_ERROR,
                            "Invalid value for ENABLE_PUSH"};
        }
        settings.SetEnablePush(setting.value);
        break;
      case 3:
        settings.SetMaxConcurrentStreams(setting.value);
        break;
      case 4:
        if (setting.value < 0 || setting.value > 2147483647) {
          return ParseError{GRPC_HTTP2_FLOW_CONTROL_ERROR,
                            "Invalid value for INITIAL_WINDOW_SIZE"};
        }
        settings.SetInitialWindowSize(setting.value);
        break;
      case 5:
        if (setting.value < 16384 || setting.value > 16777215) {
          return ParseError{GRPC_HTTP2_PROTOCOL_ERROR,
                            "Invalid value for MAX_FRAME_SIZE"};
        }
        settings.SetMaxFrameSize(setting.value);
        break;
      case 6:
        settings.SetMaxHeaderListSize(
            Clamp<uint32_t>(setting.value, 0, 16777216));
        break;
      case 65027:
        settings.SetGrpcAllowTrueBinaryMetadata(
            Clamp<uint32_t>(setting.value, 0, 1));
        break;
      case 65028:
        settings.SetGrpcPreferredReceiveCryptoFrameSize(
            Clamp<uint32_t>(setting.value, 16384, 2147483647));
        break;
      default:
        gpr_log(GPR_DEBUG, "CHTTP2: Ignoring unknown setting %d (value %d)",
                setting.id, setting.value);
        break;
    }
  }
  return settings;
}
Http2SettingsFrame Http2Settings::CreateUpdateFromBasis(
    Http2Settings basis, bool is_first_send) const {
  Http2SettingsFrame frame;
  if (header_table_size_ != basis.header_table_size_) {
    frame.settings.push_back(
        Http2SettingsFrame::Setting{1, header_table_size_});
  }
  if (enable_push_ != basis.enable_push_) {
    frame.settings.push_back(Http2SettingsFrame::Setting{2, enable_push_});
  }
  if (max_concurrent_streams_ != basis.max_concurrent_streams_) {
    frame.settings.push_back(
        Http2SettingsFrame::Setting{3, max_concurrent_streams_});
  }
  if (is_first_send || initial_window_size_ != basis.initial_window_size_) {
    frame.settings.push_back(
        Http2SettingsFrame::Setting{4, initial_window_size_});
  }
  if (max_frame_size_ != basis.max_frame_size_) {
    frame.settings.push_back(Http2SettingsFrame::Setting{5, max_frame_size_});
  }
  if (max_header_list_size_ != basis.max_header_list_size_) {
    frame.settings.push_back(
        Http2SettingsFrame::Setting{6, max_header_list_size_});
  }
  if (grpc_allow_true_binary_metadata_ !=
      basis.grpc_allow_true_binary_metadata_) {
    frame.settings.push_back(
        Http2SettingsFrame::Setting{65027, grpc_allow_true_binary_metadata_});
  }
  if (grpc_preferred_receive_crypto_frame_size_ !=
      basis.grpc_preferred_receive_crypto_frame_size_) {
    frame.settings.push_back(Http2SettingsFrame::Setting{
        65028, grpc_preferred_receive_crypto_frame_size_});
  }
  return frame;
}
Http2Settings Http2Settings::FromClientChannelArgs(
    const ChannelArgs& args) const {
  Http2Settings settings(*this);
  const auto header_table_size =
      args.GetInt(GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_DECODER);
  if (header_table_size.has_value()) {
    settings.SetHeaderTableSize(header_table_size.value());
  }
  if (args.Contains(GRPC_ARG_MAX_CONCURRENT_STREAMS)) {
    gpr_log(GPR_ERROR,
            "CHTTP2: Ignoring server-only setting on client "
            "MAX_CONCURRENT_STREAMS");
  }
  const auto max_concurrent_streams =
      args.GetInt(GRPC_ARG_MAX_CONCURRENT_STREAMS);
  if (max_concurrent_streams.has_value()) {
    settings.SetMaxConcurrentStreams(max_concurrent_streams.value());
  }
  const auto initial_window_size =
      args.GetInt(GRPC_ARG_HTTP2_STREAM_LOOKAHEAD_BYTES);
  if (initial_window_size.has_value()) {
    settings.SetInitialWindowSize(initial_window_size.value());
  }
  const auto max_frame_size = args.GetInt(GRPC_ARG_HTTP2_MAX_FRAME_SIZE);
  if (max_frame_size.has_value()) {
    settings.SetMaxFrameSize(max_frame_size.value());
  }
  const auto grpc_allow_true_binary_metadata =
      args.GetInt(GRPC_ARG_HTTP2_ENABLE_TRUE_BINARY);
  if (grpc_allow_true_binary_metadata.has_value()) {
    settings.SetGrpcAllowTrueBinaryMetadata(
        grpc_allow_true_binary_metadata.value());
  }
  return settings;
}
Http2Settings Http2Settings::FromServerChannelArgs(
    const ChannelArgs& args) const {
  Http2Settings settings(*this);
  const auto header_table_size =
      args.GetInt(GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_DECODER);
  if (header_table_size.has_value()) {
    settings.SetHeaderTableSize(header_table_size.value());
  }
  const auto max_concurrent_streams =
      args.GetInt(GRPC_ARG_MAX_CONCURRENT_STREAMS);
  if (max_concurrent_streams.has_value()) {
    settings.SetMaxConcurrentStreams(max_concurrent_streams.value());
  }
  const auto initial_window_size =
      args.GetInt(GRPC_ARG_HTTP2_STREAM_LOOKAHEAD_BYTES);
  if (initial_window_size.has_value()) {
    settings.SetInitialWindowSize(initial_window_size.value());
  }
  const auto max_frame_size = args.GetInt(GRPC_ARG_HTTP2_MAX_FRAME_SIZE);
  if (max_frame_size.has_value()) {
    settings.SetMaxFrameSize(max_frame_size.value());
  }
  const auto grpc_allow_true_binary_metadata =
      args.GetInt(GRPC_ARG_HTTP2_ENABLE_TRUE_BINARY);
  if (grpc_allow_true_binary_metadata.has_value()) {
    settings.SetGrpcAllowTrueBinaryMetadata(
        grpc_allow_true_binary_metadata.value());
  }
  return settings;
}
}  // namespace grpc_core
