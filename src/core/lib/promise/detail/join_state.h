// Copyright 2023 gRPC authors.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#ifndef GRPC_SRC_CORE_LIB_PROMISE_DETAIL_JOIN_STATE_H
#define GRPC_SRC_CORE_LIB_PROMISE_DETAIL_JOIN_STATE_H

// This file is generated by tools/codegen/core/gen_seq.py

#include <grpc/support/port_platform.h>

#include "src/core/lib/gprpp/construct_destruct.h"
#include "src/core/lib/promise/detail/promise_like.h"
#include "src/core/lib/promise/poll.h"
#include "src/core/lib/gprpp/bitset.h"

namespace grpc_core {
namespace promise_detail {
template <class Traits, typename... Ps>
struct JoinState;


template <class Traits, typename P0,typename P1>
struct JoinState<Traits, P0,P1> {
  using Promise0 = PromiseLike<P0>;
  using Result0 = typename Promise0::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise0 promise0;
    GPR_NO_UNIQUE_ADDRESS Result0 result0;
  };
  using Promise1 = PromiseLike<P1>;
  using Result1 = typename Promise1::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise1 promise1;
    GPR_NO_UNIQUE_ADDRESS Result1 result1;
  };
  GPR_NO_UNIQUE_ADDRESS BitSet<2> ready;
  JoinState(P0&& p0,P1&& p1) {
    Construct(&promise0, std::forward<P0>(p0));
    Construct(&promise1, std::forward<P1>(p1));
  }
  JoinState(const JoinState& other) {
    GPR_ASSERT(other.ready.none());
    Construct(&promise0, other.promise0);
    Construct(&promise1, other.promise1);
  }
  JoinState& operator=(const JoinState& other) = delete;
  JoinState& operator=(JoinState&& other) = delete;
  JoinState(JoinState&& other) noexcept : ready(other.ready) {
    if (ready.is_set(0)) {
      Construct(&result0, std::move(other.result0));
    } else {
      Construct(&promise0, std::move(other.promise0));
    }
    if (ready.is_set(1)) {
      Construct(&result1, std::move(other.result1));
    } else {
      Construct(&promise1, std::move(other.promise1));
    }
  }
  ~JoinState() {
    if (ready.is_set(0)) {
      Destruct(&result0);
    } else {
      Destruct(&promise0);
    }
    if (ready.is_set(1)) {
      Destruct(&result1);
    } else {
      Destruct(&promise1);
    }
  }
  using Result = std::tuple<Result0,Result1>;
  Poll<Result> PollOnce() {
    if (!ready.is_set(0)) {
      auto poll = promise0();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(0);
          Destruct(&promise0);
          Construct(Traits::Unwrapped(&result0), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (!ready.is_set(1)) {
      auto poll = promise1();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(1);
          Destruct(&promise1);
          Construct(Traits::Unwrapped(&result1), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (ready.all()) {
      return Result{std::move(result0),std::move(result1)};
    }
    return Pending{};
  }
};


template <class Traits, typename P0,typename P1,typename P2>
struct JoinState<Traits, P0,P1,P2> {
  using Promise0 = PromiseLike<P0>;
  using Result0 = typename Promise0::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise0 promise0;
    GPR_NO_UNIQUE_ADDRESS Result0 result0;
  };
  using Promise1 = PromiseLike<P1>;
  using Result1 = typename Promise1::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise1 promise1;
    GPR_NO_UNIQUE_ADDRESS Result1 result1;
  };
  using Promise2 = PromiseLike<P2>;
  using Result2 = typename Promise2::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise2 promise2;
    GPR_NO_UNIQUE_ADDRESS Result2 result2;
  };
  GPR_NO_UNIQUE_ADDRESS BitSet<3> ready;
  JoinState(P0&& p0,P1&& p1,P2&& p2) {
    Construct(&promise0, std::forward<P0>(p0));
    Construct(&promise1, std::forward<P1>(p1));
    Construct(&promise2, std::forward<P2>(p2));
  }
  JoinState(const JoinState& other) {
    GPR_ASSERT(other.ready.none());
    Construct(&promise0, other.promise0);
    Construct(&promise1, other.promise1);
    Construct(&promise2, other.promise2);
  }
  JoinState& operator=(const JoinState& other) = delete;
  JoinState& operator=(JoinState&& other) = delete;
  JoinState(JoinState&& other) noexcept : ready(other.ready) {
    if (ready.is_set(0)) {
      Construct(&result0, std::move(other.result0));
    } else {
      Construct(&promise0, std::move(other.promise0));
    }
    if (ready.is_set(1)) {
      Construct(&result1, std::move(other.result1));
    } else {
      Construct(&promise1, std::move(other.promise1));
    }
    if (ready.is_set(2)) {
      Construct(&result2, std::move(other.result2));
    } else {
      Construct(&promise2, std::move(other.promise2));
    }
  }
  ~JoinState() {
    if (ready.is_set(0)) {
      Destruct(&result0);
    } else {
      Destruct(&promise0);
    }
    if (ready.is_set(1)) {
      Destruct(&result1);
    } else {
      Destruct(&promise1);
    }
    if (ready.is_set(2)) {
      Destruct(&result2);
    } else {
      Destruct(&promise2);
    }
  }
  using Result = std::tuple<Result0,Result1,Result2>;
  Poll<Result> PollOnce() {
    if (!ready.is_set(0)) {
      auto poll = promise0();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(0);
          Destruct(&promise0);
          Construct(Traits::Unwrapped(&result0), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (!ready.is_set(1)) {
      auto poll = promise1();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(1);
          Destruct(&promise1);
          Construct(Traits::Unwrapped(&result1), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (!ready.is_set(2)) {
      auto poll = promise2();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(2);
          Destruct(&promise2);
          Construct(Traits::Unwrapped(&result2), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (ready.all()) {
      return Result{std::move(result0),std::move(result1),std::move(result2)};
    }
    return Pending{};
  }
};


template <class Traits, typename P0,typename P1,typename P2,typename P3>
struct JoinState<Traits, P0,P1,P2,P3> {
  using Promise0 = PromiseLike<P0>;
  using Result0 = typename Promise0::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise0 promise0;
    GPR_NO_UNIQUE_ADDRESS Result0 result0;
  };
  using Promise1 = PromiseLike<P1>;
  using Result1 = typename Promise1::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise1 promise1;
    GPR_NO_UNIQUE_ADDRESS Result1 result1;
  };
  using Promise2 = PromiseLike<P2>;
  using Result2 = typename Promise2::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise2 promise2;
    GPR_NO_UNIQUE_ADDRESS Result2 result2;
  };
  using Promise3 = PromiseLike<P3>;
  using Result3 = typename Promise3::Result;
  union {
    GPR_NO_UNIQUE_ADDRESS Promise3 promise3;
    GPR_NO_UNIQUE_ADDRESS Result3 result3;
  };
  GPR_NO_UNIQUE_ADDRESS BitSet<4> ready;
  JoinState(P0&& p0,P1&& p1,P2&& p2,P3&& p3) {
    Construct(&promise0, std::forward<P0>(p0));
    Construct(&promise1, std::forward<P1>(p1));
    Construct(&promise2, std::forward<P2>(p2));
    Construct(&promise3, std::forward<P3>(p3));
  }
  JoinState(const JoinState& other) {
    GPR_ASSERT(other.ready.none());
    Construct(&promise0, other.promise0);
    Construct(&promise1, other.promise1);
    Construct(&promise2, other.promise2);
    Construct(&promise3, other.promise3);
  }
  JoinState& operator=(const JoinState& other) = delete;
  JoinState& operator=(JoinState&& other) = delete;
  JoinState(JoinState&& other) noexcept : ready(other.ready) {
    if (ready.is_set(0)) {
      Construct(&result0, std::move(other.result0));
    } else {
      Construct(&promise0, std::move(other.promise0));
    }
    if (ready.is_set(1)) {
      Construct(&result1, std::move(other.result1));
    } else {
      Construct(&promise1, std::move(other.promise1));
    }
    if (ready.is_set(2)) {
      Construct(&result2, std::move(other.result2));
    } else {
      Construct(&promise2, std::move(other.promise2));
    }
    if (ready.is_set(3)) {
      Construct(&result3, std::move(other.result3));
    } else {
      Construct(&promise3, std::move(other.promise3));
    }
  }
  ~JoinState() {
    if (ready.is_set(0)) {
      Destruct(&result0);
    } else {
      Destruct(&promise0);
    }
    if (ready.is_set(1)) {
      Destruct(&result1);
    } else {
      Destruct(&promise1);
    }
    if (ready.is_set(2)) {
      Destruct(&result2);
    } else {
      Destruct(&promise2);
    }
    if (ready.is_set(3)) {
      Destruct(&result3);
    } else {
      Destruct(&promise3);
    }
  }
  using Result = std::tuple<Result0,Result1,Result2,Result3>;
  Poll<Result> PollOnce() {
    if (!ready.is_set(0)) {
      auto poll = promise0();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(0);
          Destruct(&promise0);
          Construct(Traits::Unwrapped(&result0), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (!ready.is_set(1)) {
      auto poll = promise1();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(1);
          Destruct(&promise1);
          Construct(Traits::Unwrapped(&result1), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (!ready.is_set(2)) {
      auto poll = promise2();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(2);
          Destruct(&promise2);
          Construct(Traits::Unwrapped(&result2), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (!ready.is_set(3)) {
      auto poll = promise3();
      if (auto* p = poll.value_if_ready()) {
        if (Traits::IsOk(*p)) {
          ready.set(3);
          Destruct(&promise3);
          Construct(Traits::Unwrapped(&result3), std::move(*p));
        } else {
          return Traits::IntoStatus(std::move(*p));
        }
      }
    }
    if (ready.all()) {
      return Result{std::move(result0),std::move(result1),std::move(result2),std::move(result3)};
    }
    return Pending{};
  }
};


}  // namespace promise_detail
}  // namespace grpc_core

#endif  // GRPC_SRC_CORE_LIB_PROMISE_DETAIL_JOIN_STATE_H

