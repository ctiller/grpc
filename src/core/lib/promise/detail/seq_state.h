// Copyright 2023 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef GRPC_SRC_CORE_LIB_PROMISE_DETAIL_SEQ_STATE_H
#define GRPC_SRC_CORE_LIB_PROMISE_DETAIL_SEQ_STATE_H

// This file is generated by tools/codegen/core/gen_seq.py

#include <grpc/support/port_platform.h>
#include <stdint.h>

#include <utility>

#include "absl/base/attributes.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/strings/str_cat.h"
#include "src/core/lib/debug/trace.h"
#include "src/core/lib/promise/detail/promise_factory.h"
#include "src/core/lib/promise/detail/promise_like.h"
#include "src/core/lib/promise/map.h"
#include "src/core/lib/promise/poll.h"
#include "src/core/lib/promise/promise.h"
#include "src/core/util/construct_destruct.h"
#include "src/core/util/debug_location.h"

// A sequence under some traits for some set of callables P, Fs.
// P should be a promise-like object that yields a value.
// Fs... should be promise-factory-like objects that take the value from the
// previous step and yield a promise. Note that most of the machinery in
// PromiseFactory exists to make it possible for those promise-factory-like
// objects to be anything that's convenient.
// Traits defines how we move from one step to the next. Traits sets up the
// wrapping and escape handling for the sequence.
// Promises return wrapped values that the trait can inspect and unwrap before
// passing them to the next element of the sequence. The trait can
// also interpret a wrapped value as an escape value, which terminates
// evaluation of the sequence immediately yielding a result. Traits for type T
// have the members:
//  * type UnwrappedType - the type after removing wrapping from T (i.e. for
//    TrySeq, T=StatusOr<U> yields UnwrappedType=U).
//  * type WrappedType - the type after adding wrapping if it doesn't already
//    exist (i.e. for TrySeq if T is not Status/StatusOr/void, then
//    WrappedType=StatusOr<T>; if T is Status then WrappedType=Status (it's
//    already wrapped!))
//  * template <typename Next> void CallFactory(Next* next_factory, T&& value) -
//    call promise factory next_factory with the result of unwrapping value, and
//    return the resulting promise.
//  * template <typename Result, typename RunNext> Poll<Result>
//    CheckResultAndRunNext(T prior, RunNext run_next) - examine the value of
//    prior, and decide to escape or continue. If escaping, return the final
//    sequence value of type Poll<Result>. If continuing, return the value of
//    run_next(std::move(prior)).
//
// A state contains the current promise, and the promise factory to turn the
// result of the current promise into the next state's promise. We play a shell
// game such that the prior state and our current promise are kept in a union,
// and the next promise factory is kept alongside in the state struct.
// Recursively this guarantees that the next functions get initialized once, and
// destroyed once, and don't need to be moved around in between, which avoids a
// potential O(n**2) loop of next factory moves had we used a variant of states
// here. The very first state does not have a prior state, and so that state has
// a partial specialization below. The final state does not have a next state;
// that state is inlined in BasicSeq since that was simpler to type.

namespace grpc_core {
namespace promise_detail {
template <template <typename> class Traits, typename P, typename... Fs>
struct SeqState;
template <template <typename> class Traits, typename P, typename... Fs>
struct SeqStateTypes;
template <template <typename> class Traits, typename P>
struct SeqStateTypes<Traits, P> {
  using LastPromiseResult =
      typename Traits<typename PromiseLike<P>::Result>::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0>
struct SeqStateTypes<Traits, P, F0> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using Result = typename PromiseResultTraits1::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits1::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1>
struct SeqStateTypes<Traits, P, F0, F1> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using Result = typename PromiseResultTraits2::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits2::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2>
struct SeqStateTypes<Traits, P, F0, F1, F2> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using Result = typename PromiseResultTraits3::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits3::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using Result = typename PromiseResultTraits4::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits4::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using Result = typename PromiseResultTraits5::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits5::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using Result = typename PromiseResultTraits6::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits6::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;

  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using Result = typename PromiseResultTraits7::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits7::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;

  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using NextFactory7 =
      OncePromiseFactory<typename PromiseResultTraits7::UnwrappedType, F7>;

  using Promise8 = typename NextFactory7::Promise;
  using PromiseResult8 = typename Promise8::Result;
  using PromiseResultTraits8 = Traits<PromiseResult8>;
  using Result = typename PromiseResultTraits8::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits8::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;

  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using NextFactory7 =
      OncePromiseFactory<typename PromiseResultTraits7::UnwrappedType, F7>;

  using Promise8 = typename NextFactory7::Promise;
  using PromiseResult8 = typename Promise8::Result;
  using PromiseResultTraits8 = Traits<PromiseResult8>;
  using NextFactory8 =
      OncePromiseFactory<typename PromiseResultTraits8::UnwrappedType, F8>;

  using Promise9 = typename NextFactory8::Promise;
  using PromiseResult9 = typename Promise9::Result;
  using PromiseResultTraits9 = Traits<PromiseResult9>;
  using Result = typename PromiseResultTraits9::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits9::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;

  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using NextFactory7 =
      OncePromiseFactory<typename PromiseResultTraits7::UnwrappedType, F7>;

  using Promise8 = typename NextFactory7::Promise;
  using PromiseResult8 = typename Promise8::Result;
  using PromiseResultTraits8 = Traits<PromiseResult8>;
  using NextFactory8 =
      OncePromiseFactory<typename PromiseResultTraits8::UnwrappedType, F8>;

  using Promise9 = typename NextFactory8::Promise;
  using PromiseResult9 = typename Promise9::Result;
  using PromiseResultTraits9 = Traits<PromiseResult9>;
  using NextFactory9 =
      OncePromiseFactory<typename PromiseResultTraits9::UnwrappedType, F9>;

  using Promise10 = typename NextFactory9::Promise;
  using PromiseResult10 = typename Promise10::Result;
  using PromiseResultTraits10 = Traits<PromiseResult10>;
  using Result = typename PromiseResultTraits10::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits10::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;

  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using NextFactory7 =
      OncePromiseFactory<typename PromiseResultTraits7::UnwrappedType, F7>;

  using Promise8 = typename NextFactory7::Promise;
  using PromiseResult8 = typename Promise8::Result;
  using PromiseResultTraits8 = Traits<PromiseResult8>;
  using NextFactory8 =
      OncePromiseFactory<typename PromiseResultTraits8::UnwrappedType, F8>;

  using Promise9 = typename NextFactory8::Promise;
  using PromiseResult9 = typename Promise9::Result;
  using PromiseResultTraits9 = Traits<PromiseResult9>;
  using NextFactory9 =
      OncePromiseFactory<typename PromiseResultTraits9::UnwrappedType, F9>;

  using Promise10 = typename NextFactory9::Promise;
  using PromiseResult10 = typename Promise10::Result;
  using PromiseResultTraits10 = Traits<PromiseResult10>;
  using NextFactory10 =
      OncePromiseFactory<typename PromiseResultTraits10::UnwrappedType, F10>;

  using Promise11 = typename NextFactory10::Promise;
  using PromiseResult11 = typename Promise11::Result;
  using PromiseResultTraits11 = Traits<PromiseResult11>;
  using Result = typename PromiseResultTraits11::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits11::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10,
          typename F11>
struct SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
                     F11> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;

  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;

  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;

  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;

  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;

  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;

  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;

  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using NextFactory7 =
      OncePromiseFactory<typename PromiseResultTraits7::UnwrappedType, F7>;

  using Promise8 = typename NextFactory7::Promise;
  using PromiseResult8 = typename Promise8::Result;
  using PromiseResultTraits8 = Traits<PromiseResult8>;
  using NextFactory8 =
      OncePromiseFactory<typename PromiseResultTraits8::UnwrappedType, F8>;

  using Promise9 = typename NextFactory8::Promise;
  using PromiseResult9 = typename Promise9::Result;
  using PromiseResultTraits9 = Traits<PromiseResult9>;
  using NextFactory9 =
      OncePromiseFactory<typename PromiseResultTraits9::UnwrappedType, F9>;

  using Promise10 = typename NextFactory9::Promise;
  using PromiseResult10 = typename Promise10::Result;
  using PromiseResultTraits10 = Traits<PromiseResult10>;
  using NextFactory10 =
      OncePromiseFactory<typename PromiseResultTraits10::UnwrappedType, F10>;

  using Promise11 = typename NextFactory10::Promise;
  using PromiseResult11 = typename Promise11::Result;
  using PromiseResultTraits11 = Traits<PromiseResult11>;
  using NextFactory11 =
      OncePromiseFactory<typename PromiseResultTraits11::UnwrappedType, F11>;

  using Promise12 = typename NextFactory11::Promise;
  using PromiseResult12 = typename Promise12::Result;
  using PromiseResultTraits12 = Traits<PromiseResult12>;
  using Result = typename PromiseResultTraits12::WrappedType;
  using LastPromiseResult = typename PromiseResultTraits12::UnwrappedType;
};

template <template <typename> class Traits, typename P, typename F0>
struct SeqState<Traits, P, F0> {
  using Types = SeqStateTypes<Traits, P, F0>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using NextFactory0 = typename Types::NextFactory0;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running0 prior;
    GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
  };
  enum class State : uint8_t { kState0, kState1 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.current_promise, std::forward<P>(p));
    Construct(&prior.next_factory, std::forward<F0>(f0));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.current_promise, other.prior.current_promise);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.current_promise, std::move(other.prior.current_promise));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/2";
        auto result = prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/2 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      default:
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/2";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/2 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1>
struct SeqState<Traits, P, F0, F1> {
  using Types = SeqStateTypes<Traits, P, F0, F1>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running1 prior;
    GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
  };
  enum class State : uint8_t { kState0, kState1, kState2 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.current_promise, std::forward<P>(p));
    Construct(&prior.prior.next_factory, std::forward<F0>(f0));
    Construct(&prior.next_factory, std::forward<F1>(f1));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.next_factory);
  tail1:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.current_promise, other.prior.prior.current_promise);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.current_promise,
              std::move(other.prior.prior.current_promise));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/3";
        auto result = prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/3 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/3";
        auto result = prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/3 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      default:
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/3";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/3 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2>
struct SeqState<Traits, P, F0, F1, F2> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running2 prior;
    GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
  };
  enum class State : uint8_t { kState0, kState1, kState2, kState3 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.current_promise, std::forward<P>(p));
    Construct(&prior.prior.prior.next_factory, std::forward<F0>(f0));
    Construct(&prior.prior.next_factory, std::forward<F1>(f1));
    Construct(&prior.next_factory, std::forward<F2>(f2));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.next_factory);
  tail2:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.current_promise,
              other.prior.prior.prior.current_promise);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.current_promise,
              std::move(other.prior.prior.prior.current_promise));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/4";
        auto result = prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/4 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/4";
        auto result = prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/4 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/4";
        auto result = prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/4 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      default:
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/4";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/4 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3>
struct SeqState<Traits, P, F0, F1, F2, F3> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running3 prior;
    GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
  };
  enum class State : uint8_t { kState0, kState1, kState2, kState3, kState4 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.current_promise, std::forward<P>(p));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F0>(f0));
    Construct(&prior.prior.prior.next_factory, std::forward<F1>(f1));
    Construct(&prior.prior.next_factory, std::forward<F2>(f2));
    Construct(&prior.next_factory, std::forward<F3>(f3));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.next_factory);
  tail3:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.current_promise,
              other.prior.prior.prior.prior.current_promise);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.current_promise,
              std::move(other.prior.prior.prior.prior.current_promise));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/5";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/5 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/5";
        auto result = prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/5 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/5";
        auto result = prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/5 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/5";
        auto result = prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/5 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      default:
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/5";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/5 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4>
struct SeqState<Traits, P, F0, F1, F2, F3, F4> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running4 prior;
    GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F1>(f1));
    Construct(&prior.prior.prior.next_factory, std::forward<F2>(f2));
    Construct(&prior.prior.next_factory, std::forward<F3>(f3));
    Construct(&prior.next_factory, std::forward<F4>(f4));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.next_factory);
  tail4:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.current_promise,
              other.prior.prior.prior.prior.prior.current_promise);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.current_promise,
              std::move(other.prior.prior.prior.prior.prior.current_promise));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/6";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/6 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/6";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/6 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/6";
        auto result = prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/6 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/6";
        auto result = prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/6 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/6";
        auto result = prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/6 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      default:
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/6";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/6 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running5 prior;
    GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F2>(f2));
    Construct(&prior.prior.prior.next_factory, std::forward<F3>(f3));
    Construct(&prior.prior.next_factory, std::forward<F4>(f4));
    Construct(&prior.next_factory, std::forward<F5>(f5));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.next_factory);
  tail5:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.current_promise,
              other.prior.prior.prior.prior.prior.prior.current_promise);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(
        &prior.prior.prior.prior.prior.prior.current_promise,
        std::move(other.prior.prior.prior.prior.prior.prior.current_promise));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/7";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/7 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/7";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/7 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/7";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/7 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/7";
        auto result = prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/7 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/7";
        auto result = prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/7 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/7";
        auto result = prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/7 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      default:
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/7";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/7 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using Promise7 = typename Types::Promise7;
  using PromiseResult7 = typename Types::PromiseResult7;
  using PromiseResultTraits7 = typename Types::PromiseResultTraits7;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using NextFactory6 = typename Types::NextFactory6;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running5 prior;
      GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory6 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running6 prior;
    GPR_NO_UNIQUE_ADDRESS Promise7 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5, F6&& f6,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F3>(f3));
    Construct(&prior.prior.prior.next_factory, std::forward<F4>(f4));
    Construct(&prior.prior.next_factory, std::forward<F5>(f5));
    Construct(&prior.next_factory, std::forward<F6>(f6));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.next_factory);
  tail6:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
              other.prior.prior.prior.prior.prior.prior.prior.current_promise);
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.current_promise,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.current_promise));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/8";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/8";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/8";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/8";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/8";
        auto result = prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/8";
        auto result = prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/8";
        auto result = prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/8 gets "
            << (p != nullptr
                    ? (PromiseResultTraits6::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits6::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState7;
      }
        [[fallthrough]];
      default:
      case State::kState7: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 8/8";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 8/8 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using Promise7 = typename Types::Promise7;
  using PromiseResult7 = typename Types::PromiseResult7;
  using PromiseResultTraits7 = typename Types::PromiseResultTraits7;
  using Promise8 = typename Types::Promise8;
  using PromiseResult8 = typename Types::PromiseResult8;
  using PromiseResultTraits8 = typename Types::PromiseResultTraits8;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using NextFactory6 = typename Types::NextFactory6;
  using NextFactory7 = typename Types::NextFactory7;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running5 prior;
      GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory6 next_factory;
  };
  struct Running7 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running6 prior;
      GPR_NO_UNIQUE_ADDRESS Promise7 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory7 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running7 prior;
    GPR_NO_UNIQUE_ADDRESS Promise8 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7,
    kState8
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5, F6&& f6, F7&& f7,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F3>(f3));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F4>(f4));
    Construct(&prior.prior.prior.next_factory, std::forward<F5>(f5));
    Construct(&prior.prior.next_factory, std::forward<F6>(f6));
    Construct(&prior.next_factory, std::forward<F7>(f7));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&prior.current_promise);
        goto tail7;
      case State::kState8:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.prior.next_factory);
  tail6:
    Destruct(&prior.prior.next_factory);
  tail7:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
        other.prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .current_promise));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/9";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/9";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/9";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/9";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/9";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/9";
        auto result = prior.prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/9";
        auto result = prior.prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits6::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits6::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState7;
      }
        [[fallthrough]];
      case State::kState7: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 8/9";
        auto result = prior.current_promise();
        PromiseResult7* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 8/9 gets "
            << (p != nullptr
                    ? (PromiseResultTraits7::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits7::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits7::IsOk(*p)) {
          return PromiseResultTraits7::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits7::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState8;
      }
        [[fallthrough]];
      default:
      case State::kState8: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 9/9";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 9/9 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using Promise7 = typename Types::Promise7;
  using PromiseResult7 = typename Types::PromiseResult7;
  using PromiseResultTraits7 = typename Types::PromiseResultTraits7;
  using Promise8 = typename Types::Promise8;
  using PromiseResult8 = typename Types::PromiseResult8;
  using PromiseResultTraits8 = typename Types::PromiseResultTraits8;
  using Promise9 = typename Types::Promise9;
  using PromiseResult9 = typename Types::PromiseResult9;
  using PromiseResultTraits9 = typename Types::PromiseResultTraits9;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using NextFactory6 = typename Types::NextFactory6;
  using NextFactory7 = typename Types::NextFactory7;
  using NextFactory8 = typename Types::NextFactory8;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running5 prior;
      GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory6 next_factory;
  };
  struct Running7 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running6 prior;
      GPR_NO_UNIQUE_ADDRESS Promise7 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory7 next_factory;
  };
  struct Running8 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running7 prior;
      GPR_NO_UNIQUE_ADDRESS Promise8 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory8 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running8 prior;
    GPR_NO_UNIQUE_ADDRESS Promise9 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7,
    kState8,
    kState9
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5, F6&& f6, F7&& f7,
                                                F8&& f8,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
        std::forward<P>(p));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F3>(f3));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F4>(f4));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F5>(f5));
    Construct(&prior.prior.prior.next_factory, std::forward<F6>(f6));
    Construct(&prior.prior.next_factory, std::forward<F7>(f7));
    Construct(&prior.next_factory, std::forward<F8>(f8));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail0;
      case State::kState1:
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.prior.prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&prior.prior.current_promise);
        goto tail7;
      case State::kState8:
        Destruct(&prior.current_promise);
        goto tail8;
      case State::kState9:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail6:
    Destruct(&prior.prior.prior.next_factory);
  tail7:
    Destruct(&prior.prior.next_factory);
  tail8:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
        other.prior.prior.prior.prior.prior.prior.prior.prior.prior
            .current_promise);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.prior
            .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
        std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/10";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
            std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/10";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/10";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/10";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/10";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/10";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/10";
        auto result = prior.prior.prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits6::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits6::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState7;
      }
        [[fallthrough]];
      case State::kState7: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 8/10";
        auto result = prior.prior.current_promise();
        PromiseResult7* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 8/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits7::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits7::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits7::IsOk(*p)) {
          return PromiseResultTraits7::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits7::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState8;
      }
        [[fallthrough]];
      case State::kState8: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 9/10";
        auto result = prior.current_promise();
        PromiseResult8* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 9/10 gets "
            << (p != nullptr
                    ? (PromiseResultTraits8::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits8::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits8::IsOk(*p)) {
          return PromiseResultTraits8::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits8::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState9;
      }
        [[fallthrough]];
      default:
      case State::kState9: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 10/10";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 10/10 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using Promise7 = typename Types::Promise7;
  using PromiseResult7 = typename Types::PromiseResult7;
  using PromiseResultTraits7 = typename Types::PromiseResultTraits7;
  using Promise8 = typename Types::Promise8;
  using PromiseResult8 = typename Types::PromiseResult8;
  using PromiseResultTraits8 = typename Types::PromiseResultTraits8;
  using Promise9 = typename Types::Promise9;
  using PromiseResult9 = typename Types::PromiseResult9;
  using PromiseResultTraits9 = typename Types::PromiseResultTraits9;
  using Promise10 = typename Types::Promise10;
  using PromiseResult10 = typename Types::PromiseResult10;
  using PromiseResultTraits10 = typename Types::PromiseResultTraits10;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using NextFactory6 = typename Types::NextFactory6;
  using NextFactory7 = typename Types::NextFactory7;
  using NextFactory8 = typename Types::NextFactory8;
  using NextFactory9 = typename Types::NextFactory9;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running5 prior;
      GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory6 next_factory;
  };
  struct Running7 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running6 prior;
      GPR_NO_UNIQUE_ADDRESS Promise7 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory7 next_factory;
  };
  struct Running8 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running7 prior;
      GPR_NO_UNIQUE_ADDRESS Promise8 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory8 next_factory;
  };
  struct Running9 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running8 prior;
      GPR_NO_UNIQUE_ADDRESS Promise9 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory9 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running9 prior;
    GPR_NO_UNIQUE_ADDRESS Promise10 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7,
    kState8,
    kState9,
    kState10
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5, F6&& f6, F7&& f7,
                                                F8&& f8, F9&& f9,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::forward<F0>(f0));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F3>(f3));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F4>(f4));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F5>(f5));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F6>(f6));
    Construct(&prior.prior.prior.next_factory, std::forward<F7>(f7));
    Construct(&prior.prior.next_factory, std::forward<F8>(f8));
    Construct(&prior.next_factory, std::forward<F9>(f9));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail1;
      case State::kState2:
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&prior.prior.prior.current_promise);
        goto tail7;
      case State::kState8:
        Destruct(&prior.prior.current_promise);
        goto tail8;
      case State::kState9:
        Destruct(&prior.current_promise);
        goto tail9;
      case State::kState10:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
  tail1:
    Destruct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail6:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail7:
    Destruct(&prior.prior.prior.next_factory);
  tail8:
    Destruct(&prior.prior.next_factory);
  tail9:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .current_promise,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .current_promise);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.prior
            .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .current_promise,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.current_promise));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/11";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                 .next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                       .current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/11";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
            std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/11";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/11";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/11";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/11";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/11";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits6::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits6::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState7;
      }
        [[fallthrough]];
      case State::kState7: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 8/11";
        auto result = prior.prior.prior.current_promise();
        PromiseResult7* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 8/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits7::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits7::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits7::IsOk(*p)) {
          return PromiseResultTraits7::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits7::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState8;
      }
        [[fallthrough]];
      case State::kState8: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 9/11";
        auto result = prior.prior.current_promise();
        PromiseResult8* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 9/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits8::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits8::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits8::IsOk(*p)) {
          return PromiseResultTraits8::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits8::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState9;
      }
        [[fallthrough]];
      case State::kState9: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 10/11";
        auto result = prior.current_promise();
        PromiseResult9* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 10/11 gets "
            << (p != nullptr
                    ? (PromiseResultTraits9::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits9::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits9::IsOk(*p)) {
          return PromiseResultTraits9::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits9::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState10;
      }
        [[fallthrough]];
      default:
      case State::kState10: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 11/11";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 11/11 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using Promise7 = typename Types::Promise7;
  using PromiseResult7 = typename Types::PromiseResult7;
  using PromiseResultTraits7 = typename Types::PromiseResultTraits7;
  using Promise8 = typename Types::Promise8;
  using PromiseResult8 = typename Types::PromiseResult8;
  using PromiseResultTraits8 = typename Types::PromiseResultTraits8;
  using Promise9 = typename Types::Promise9;
  using PromiseResult9 = typename Types::PromiseResult9;
  using PromiseResultTraits9 = typename Types::PromiseResultTraits9;
  using Promise10 = typename Types::Promise10;
  using PromiseResult10 = typename Types::PromiseResult10;
  using PromiseResultTraits10 = typename Types::PromiseResultTraits10;
  using Promise11 = typename Types::Promise11;
  using PromiseResult11 = typename Types::PromiseResult11;
  using PromiseResultTraits11 = typename Types::PromiseResultTraits11;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using NextFactory6 = typename Types::NextFactory6;
  using NextFactory7 = typename Types::NextFactory7;
  using NextFactory8 = typename Types::NextFactory8;
  using NextFactory9 = typename Types::NextFactory9;
  using NextFactory10 = typename Types::NextFactory10;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running5 prior;
      GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory6 next_factory;
  };
  struct Running7 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running6 prior;
      GPR_NO_UNIQUE_ADDRESS Promise7 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory7 next_factory;
  };
  struct Running8 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running7 prior;
      GPR_NO_UNIQUE_ADDRESS Promise8 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory8 next_factory;
  };
  struct Running9 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running8 prior;
      GPR_NO_UNIQUE_ADDRESS Promise9 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory9 next_factory;
  };
  struct Running10 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running9 prior;
      GPR_NO_UNIQUE_ADDRESS Promise10 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory10 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running10 prior;
    GPR_NO_UNIQUE_ADDRESS Promise11 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7,
    kState8,
    kState9,
    kState10,
    kState11
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5, F6&& f6, F7&& f7,
                                                F8&& f8, F9&& f9, F10&& f10,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::forward<F1>(f1));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F3>(f3));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F4>(f4));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F5>(f5));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F6>(f6));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F7>(f7));
    Construct(&prior.prior.prior.next_factory, std::forward<F8>(f8));
    Construct(&prior.prior.next_factory, std::forward<F9>(f9));
    Construct(&prior.next_factory, std::forward<F10>(f10));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail2;
      case State::kState3:
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail7;
      case State::kState8:
        Destruct(&prior.prior.prior.current_promise);
        goto tail8;
      case State::kState9:
        Destruct(&prior.prior.current_promise);
        goto tail9;
      case State::kState10:
        Destruct(&prior.current_promise);
        goto tail10;
      case State::kState11:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
  tail2:
    Destruct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail6:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail7:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail8:
    Destruct(&prior.prior.prior.next_factory);
  tail9:
    Destruct(&prior.prior.next_factory);
  tail10:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .current_promise,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .prior.current_promise);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.prior
            .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .current_promise,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.prior.current_promise));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/12";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                 .next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                       .current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/12";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                 .next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                       .current_promise,
                  std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/12";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
            std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/12";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/12";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/12";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/12";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits6::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits6::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState7;
      }
        [[fallthrough]];
      case State::kState7: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 8/12";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult7* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 8/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits7::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits7::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits7::IsOk(*p)) {
          return PromiseResultTraits7::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits7::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState8;
      }
        [[fallthrough]];
      case State::kState8: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 9/12";
        auto result = prior.prior.prior.current_promise();
        PromiseResult8* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 9/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits8::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits8::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits8::IsOk(*p)) {
          return PromiseResultTraits8::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits8::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState9;
      }
        [[fallthrough]];
      case State::kState9: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 10/12";
        auto result = prior.prior.current_promise();
        PromiseResult9* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 10/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits9::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits9::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits9::IsOk(*p)) {
          return PromiseResultTraits9::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits9::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState10;
      }
        [[fallthrough]];
      case State::kState10: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 11/12";
        auto result = prior.current_promise();
        PromiseResult10* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 11/12 gets "
            << (p != nullptr
                    ? (PromiseResultTraits10::IsOk(*p)
                           ? "ready"
                           : absl::StrCat(
                                 "early-error:",
                                 PromiseResultTraits10::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits10::IsOk(*p)) {
          return PromiseResultTraits10::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits10::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState11;
      }
        [[fallthrough]];
      default:
      case State::kState11: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 12/12";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 12/12 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10,
          typename F11>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9,
                              F10, F11>;
  using Promise0 = typename Types::Promise0;
  using PromiseResult0 = typename Types::PromiseResult0;
  using PromiseResultTraits0 = typename Types::PromiseResultTraits0;
  using Promise1 = typename Types::Promise1;
  using PromiseResult1 = typename Types::PromiseResult1;
  using PromiseResultTraits1 = typename Types::PromiseResultTraits1;
  using Promise2 = typename Types::Promise2;
  using PromiseResult2 = typename Types::PromiseResult2;
  using PromiseResultTraits2 = typename Types::PromiseResultTraits2;
  using Promise3 = typename Types::Promise3;
  using PromiseResult3 = typename Types::PromiseResult3;
  using PromiseResultTraits3 = typename Types::PromiseResultTraits3;
  using Promise4 = typename Types::Promise4;
  using PromiseResult4 = typename Types::PromiseResult4;
  using PromiseResultTraits4 = typename Types::PromiseResultTraits4;
  using Promise5 = typename Types::Promise5;
  using PromiseResult5 = typename Types::PromiseResult5;
  using PromiseResultTraits5 = typename Types::PromiseResultTraits5;
  using Promise6 = typename Types::Promise6;
  using PromiseResult6 = typename Types::PromiseResult6;
  using PromiseResultTraits6 = typename Types::PromiseResultTraits6;
  using Promise7 = typename Types::Promise7;
  using PromiseResult7 = typename Types::PromiseResult7;
  using PromiseResultTraits7 = typename Types::PromiseResultTraits7;
  using Promise8 = typename Types::Promise8;
  using PromiseResult8 = typename Types::PromiseResult8;
  using PromiseResultTraits8 = typename Types::PromiseResultTraits8;
  using Promise9 = typename Types::Promise9;
  using PromiseResult9 = typename Types::PromiseResult9;
  using PromiseResultTraits9 = typename Types::PromiseResultTraits9;
  using Promise10 = typename Types::Promise10;
  using PromiseResult10 = typename Types::PromiseResult10;
  using PromiseResultTraits10 = typename Types::PromiseResultTraits10;
  using Promise11 = typename Types::Promise11;
  using PromiseResult11 = typename Types::PromiseResult11;
  using PromiseResultTraits11 = typename Types::PromiseResultTraits11;
  using Promise12 = typename Types::Promise12;
  using PromiseResult12 = typename Types::PromiseResult12;
  using PromiseResultTraits12 = typename Types::PromiseResultTraits12;
  using NextFactory0 = typename Types::NextFactory0;
  using NextFactory1 = typename Types::NextFactory1;
  using NextFactory2 = typename Types::NextFactory2;
  using NextFactory3 = typename Types::NextFactory3;
  using NextFactory4 = typename Types::NextFactory4;
  using NextFactory5 = typename Types::NextFactory5;
  using NextFactory6 = typename Types::NextFactory6;
  using NextFactory7 = typename Types::NextFactory7;
  using NextFactory8 = typename Types::NextFactory8;
  using NextFactory9 = typename Types::NextFactory9;
  using NextFactory10 = typename Types::NextFactory10;
  using NextFactory11 = typename Types::NextFactory11;
  using Result = typename Types::Result;
  struct Running0 {
    GPR_NO_UNIQUE_ADDRESS Promise0 current_promise;
    GPR_NO_UNIQUE_ADDRESS NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running0 prior;
      GPR_NO_UNIQUE_ADDRESS Promise1 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running1 prior;
      GPR_NO_UNIQUE_ADDRESS Promise2 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running2 prior;
      GPR_NO_UNIQUE_ADDRESS Promise3 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running3 prior;
      GPR_NO_UNIQUE_ADDRESS Promise4 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running4 prior;
      GPR_NO_UNIQUE_ADDRESS Promise5 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running5 prior;
      GPR_NO_UNIQUE_ADDRESS Promise6 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory6 next_factory;
  };
  struct Running7 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running6 prior;
      GPR_NO_UNIQUE_ADDRESS Promise7 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory7 next_factory;
  };
  struct Running8 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running7 prior;
      GPR_NO_UNIQUE_ADDRESS Promise8 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory8 next_factory;
  };
  struct Running9 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running8 prior;
      GPR_NO_UNIQUE_ADDRESS Promise9 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory9 next_factory;
  };
  struct Running10 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running9 prior;
      GPR_NO_UNIQUE_ADDRESS Promise10 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory10 next_factory;
  };
  struct Running11 {
    union {
      GPR_NO_UNIQUE_ADDRESS Running10 prior;
      GPR_NO_UNIQUE_ADDRESS Promise11 current_promise;
    };
    GPR_NO_UNIQUE_ADDRESS NextFactory11 next_factory;
  };
  union {
    GPR_NO_UNIQUE_ADDRESS Running11 prior;
    GPR_NO_UNIQUE_ADDRESS Promise12 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7,
    kState8,
    kState9,
    kState10,
    kState11,
    kState12
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;
  GPR_NO_UNIQUE_ADDRESS DebugLocation whence;

  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(P&& p, F0&& f0, F1&& f1,
                                                F2&& f2, F3&& f3, F4&& f4,
                                                F5&& f5, F6&& f6, F7&& f7,
                                                F8&& f8, F9&& f9, F10&& f10,
                                                F11&& f11,
                                                DebugLocation whence) noexcept
      : whence(whence) {
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::forward<F2>(f2));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::forward<F3>(f3));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F4>(f4));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F5>(f5));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F6>(f6));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F7>(f7));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F8>(f8));
    Construct(&prior.prior.prior.next_factory, std::forward<F9>(f9));
    Construct(&prior.prior.next_factory, std::forward<F10>(f10));
    Construct(&prior.next_factory, std::forward<F11>(f11));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        goto tail3;
      case State::kState4:
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail7;
      case State::kState8:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail8;
      case State::kState9:
        Destruct(&prior.prior.prior.current_promise);
        goto tail9;
      case State::kState10:
        Destruct(&prior.prior.current_promise);
        goto tail10;
      case State::kState11:
        Destruct(&prior.current_promise);
        goto tail11;
      case State::kState12:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
  tail3:
    Destruct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail6:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail7:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail8:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail9:
    Destruct(&prior.prior.prior.next_factory);
  tail10:
    Destruct(&prior.prior.next_factory);
  tail11:
    Destruct(&prior.next_factory);
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .prior.current_promise,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .prior.prior.current_promise);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                  .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.prior
            .next_factory);
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        other.prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.prior.next_factory,
              other.prior.prior.prior.prior.next_factory);
    Construct(&prior.prior.prior.next_factory,
              other.prior.prior.prior.next_factory);
    Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
    Construct(&prior.next_factory, other.prior.next_factory);
  }
  SeqState& operator=(const SeqState& other) = delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
      : state(other.state), whence(other.whence) {
    DCHECK(state == State::kState0);
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .prior.current_promise,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.prior.prior.current_promise));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                   .next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState& operator=(SeqState&& other) =
      delete;
  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Poll<Result> operator()() {
    switch (state) {
      case State::kState0: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 1/13";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 1/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits0::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits0::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                 .prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                       .prior.current_promise,
                  std::move(next_promise));
        state = State::kState1;
      }
        [[fallthrough]];
      case State::kState1: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 2/13";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 2/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits1::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits1::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                 .next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                       .current_promise,
                  std::move(next_promise));
        state = State::kState2;
      }
        [[fallthrough]];
      case State::kState2: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 3/13";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 3/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits2::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits2::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                 .next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                       .current_promise,
                  std::move(next_promise));
        state = State::kState3;
      }
        [[fallthrough]];
      case State::kState3: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 4/13";
        auto result = prior.prior.prior.prior.prior.prior.prior.prior.prior
                          .current_promise();
        PromiseResult3* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 4/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits3::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits3::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.prior
                      .next_factory);
        Construct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
            std::move(next_promise));
        state = State::kState4;
      }
        [[fallthrough]];
      case State::kState4: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 5/13";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 5/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits4::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits4::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState5;
      }
        [[fallthrough]];
      case State::kState5: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 6/13";
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 6/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits5::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits5::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState6;
      }
        [[fallthrough]];
      case State::kState6: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 7/13";
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 7/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits6::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits6::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState7;
      }
        [[fallthrough]];
      case State::kState7: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 8/13";
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult7* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 8/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits7::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits7::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits7::IsOk(*p)) {
          return PromiseResultTraits7::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits7::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
        state = State::kState8;
      }
        [[fallthrough]];
      case State::kState8: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 9/13";
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult8* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 9/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits8::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits8::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits8::IsOk(*p)) {
          return PromiseResultTraits8::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits8::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
        state = State::kState9;
      }
        [[fallthrough]];
      case State::kState9: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 10/13";
        auto result = prior.prior.prior.current_promise();
        PromiseResult9* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 10/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits9::IsOk(*p)
                           ? "ready"
                           : absl::StrCat("early-error:",
                                          PromiseResultTraits9::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits9::IsOk(*p)) {
          return PromiseResultTraits9::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits9::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
        state = State::kState10;
      }
        [[fallthrough]];
      case State::kState10: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 11/13";
        auto result = prior.prior.current_promise();
        PromiseResult10* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 11/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits10::IsOk(*p)
                           ? "ready"
                           : absl::StrCat(
                                 "early-error:",
                                 PromiseResultTraits10::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits10::IsOk(*p)) {
          return PromiseResultTraits10::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits10::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
        state = State::kState11;
      }
        [[fallthrough]];
      case State::kState11: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 12/13";
        auto result = prior.current_promise();
        PromiseResult11* p = result.value_if_ready();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 12/13 gets "
            << (p != nullptr
                    ? (PromiseResultTraits11::IsOk(*p)
                           ? "ready"
                           : absl::StrCat(
                                 "early-error:",
                                 PromiseResultTraits11::ErrorString(*p))
                                 .c_str())
                    : "pending");
        if (p == nullptr) return Pending{};
        if (!PromiseResultTraits11::IsOk(*p)) {
          return PromiseResultTraits11::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits11::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
        state = State::kState12;
      }
        [[fallthrough]];
      default:
      case State::kState12: {
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: begin poll step 13/13";
        auto result = current_promise();
        GRPC_TRACE_LOG(promise_primitives, INFO)
                .AtLocation(whence.file(), whence.line())
            << "seq[" << this << "]: poll step 13/13 gets "
            << (result.ready() ? "ready" : "pending");
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0) {
  using Types = SeqStateTypes<Traits, P, F0>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1) {
  using Types = SeqStateTypes<Traits, P, F0, F1>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5, F6&& f6) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5)),
              f6 = typename Types::NextFactory6(std::forward<F6>(f6))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               typename Types::PromiseResult6 r6 =
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5));
               if (!Types::PromiseResultTraits6::IsOk(r6)) {
                 return Types::PromiseResultTraits6::template ReturnValue<
                     typename Types::Result>(std::move(r6));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits6::CallFactoryThenPromise(
                       &f6, std::move(r6)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5, F6&& f6, F7&& f7) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5)),
              f6 = typename Types::NextFactory6(std::forward<F6>(f6)),
              f7 = typename Types::NextFactory7(std::forward<F7>(f7))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               typename Types::PromiseResult6 r6 =
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5));
               if (!Types::PromiseResultTraits6::IsOk(r6)) {
                 return Types::PromiseResultTraits6::template ReturnValue<
                     typename Types::Result>(std::move(r6));
               }
               typename Types::PromiseResult7 r7 =
                   Types::PromiseResultTraits6::CallFactoryThenPromise(
                       &f6, std::move(r6));
               if (!Types::PromiseResultTraits7::IsOk(r7)) {
                 return Types::PromiseResultTraits7::template ReturnValue<
                     typename Types::Result>(std::move(r7));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits7::CallFactoryThenPromise(
                       &f7, std::move(r7)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5, F6&& f6, F7&& f7,
                                                 F8&& f8) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5)),
              f6 = typename Types::NextFactory6(std::forward<F6>(f6)),
              f7 = typename Types::NextFactory7(std::forward<F7>(f7)),
              f8 = typename Types::NextFactory8(std::forward<F8>(f8))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               typename Types::PromiseResult6 r6 =
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5));
               if (!Types::PromiseResultTraits6::IsOk(r6)) {
                 return Types::PromiseResultTraits6::template ReturnValue<
                     typename Types::Result>(std::move(r6));
               }
               typename Types::PromiseResult7 r7 =
                   Types::PromiseResultTraits6::CallFactoryThenPromise(
                       &f6, std::move(r6));
               if (!Types::PromiseResultTraits7::IsOk(r7)) {
                 return Types::PromiseResultTraits7::template ReturnValue<
                     typename Types::Result>(std::move(r7));
               }
               typename Types::PromiseResult8 r8 =
                   Types::PromiseResultTraits7::CallFactoryThenPromise(
                       &f7, std::move(r7));
               if (!Types::PromiseResultTraits8::IsOk(r8)) {
                 return Types::PromiseResultTraits8::template ReturnValue<
                     typename Types::Result>(std::move(r8));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits8::CallFactoryThenPromise(
                       &f8, std::move(r8)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5, F6&& f6, F7&& f7,
                                                 F8&& f8, F9&& f9) {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5)),
              f6 = typename Types::NextFactory6(std::forward<F6>(f6)),
              f7 = typename Types::NextFactory7(std::forward<F7>(f7)),
              f8 = typename Types::NextFactory8(std::forward<F8>(f8)),
              f9 = typename Types::NextFactory9(std::forward<F9>(f9))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               typename Types::PromiseResult6 r6 =
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5));
               if (!Types::PromiseResultTraits6::IsOk(r6)) {
                 return Types::PromiseResultTraits6::template ReturnValue<
                     typename Types::Result>(std::move(r6));
               }
               typename Types::PromiseResult7 r7 =
                   Types::PromiseResultTraits6::CallFactoryThenPromise(
                       &f6, std::move(r6));
               if (!Types::PromiseResultTraits7::IsOk(r7)) {
                 return Types::PromiseResultTraits7::template ReturnValue<
                     typename Types::Result>(std::move(r7));
               }
               typename Types::PromiseResult8 r8 =
                   Types::PromiseResultTraits7::CallFactoryThenPromise(
                       &f7, std::move(r7));
               if (!Types::PromiseResultTraits8::IsOk(r8)) {
                 return Types::PromiseResultTraits8::template ReturnValue<
                     typename Types::Result>(std::move(r8));
               }
               typename Types::PromiseResult9 r9 =
                   Types::PromiseResultTraits8::CallFactoryThenPromise(
                       &f8, std::move(r8));
               if (!Types::PromiseResultTraits9::IsOk(r9)) {
                 return Types::PromiseResultTraits9::template ReturnValue<
                     typename Types::Result>(std::move(r9));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits9::CallFactoryThenPromise(
                       &f9, std::move(r9)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5, F6&& f6, F7&& f7,
                                                 F8&& f8, F9&& f9, F10&& f10) {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5)),
              f6 = typename Types::NextFactory6(std::forward<F6>(f6)),
              f7 = typename Types::NextFactory7(std::forward<F7>(f7)),
              f8 = typename Types::NextFactory8(std::forward<F8>(f8)),
              f9 = typename Types::NextFactory9(std::forward<F9>(f9)),
              f10 = typename Types::NextFactory10(std::forward<F10>(f10))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               typename Types::PromiseResult6 r6 =
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5));
               if (!Types::PromiseResultTraits6::IsOk(r6)) {
                 return Types::PromiseResultTraits6::template ReturnValue<
                     typename Types::Result>(std::move(r6));
               }
               typename Types::PromiseResult7 r7 =
                   Types::PromiseResultTraits6::CallFactoryThenPromise(
                       &f6, std::move(r6));
               if (!Types::PromiseResultTraits7::IsOk(r7)) {
                 return Types::PromiseResultTraits7::template ReturnValue<
                     typename Types::Result>(std::move(r7));
               }
               typename Types::PromiseResult8 r8 =
                   Types::PromiseResultTraits7::CallFactoryThenPromise(
                       &f7, std::move(r7));
               if (!Types::PromiseResultTraits8::IsOk(r8)) {
                 return Types::PromiseResultTraits8::template ReturnValue<
                     typename Types::Result>(std::move(r8));
               }
               typename Types::PromiseResult9 r9 =
                   Types::PromiseResultTraits8::CallFactoryThenPromise(
                       &f8, std::move(r8));
               if (!Types::PromiseResultTraits9::IsOk(r9)) {
                 return Types::PromiseResultTraits9::template ReturnValue<
                     typename Types::Result>(std::move(r9));
               }
               typename Types::PromiseResult10 r10 =
                   Types::PromiseResultTraits9::CallFactoryThenPromise(
                       &f9, std::move(r9));
               if (!Types::PromiseResultTraits10::IsOk(r10)) {
                 return Types::PromiseResultTraits10::template ReturnValue<
                     typename Types::Result>(std::move(r10));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits10::CallFactoryThenPromise(
                       &f10, std::move(r10)));
             });
}

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10,
          typename F11>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqMap(P&& p, F0&& f0, F1&& f1,
                                                 F2&& f2, F3&& f3, F4&& f4,
                                                 F5&& f5, F6&& f6, F7&& f7,
                                                 F8&& f8, F9&& f9, F10&& f10,
                                                 F11&& f11) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9,
                              F10, F11>;
  return Map(std::forward<P>(p),
             [f0 = typename Types::NextFactory0(std::forward<F0>(f0)),
              f1 = typename Types::NextFactory1(std::forward<F1>(f1)),
              f2 = typename Types::NextFactory2(std::forward<F2>(f2)),
              f3 = typename Types::NextFactory3(std::forward<F3>(f3)),
              f4 = typename Types::NextFactory4(std::forward<F4>(f4)),
              f5 = typename Types::NextFactory5(std::forward<F5>(f5)),
              f6 = typename Types::NextFactory6(std::forward<F6>(f6)),
              f7 = typename Types::NextFactory7(std::forward<F7>(f7)),
              f8 = typename Types::NextFactory8(std::forward<F8>(f8)),
              f9 = typename Types::NextFactory9(std::forward<F9>(f9)),
              f10 = typename Types::NextFactory10(std::forward<F10>(f10)),
              f11 = typename Types::NextFactory11(std::forward<F11>(f11))](
                 typename Types::PromiseResult0 r0) mutable {
               if (!Types::PromiseResultTraits0::IsOk(r0)) {
                 return Types::PromiseResultTraits0::template ReturnValue<
                     typename Types::Result>(std::move(r0));
               }
               typename Types::PromiseResult1 r1 =
                   Types::PromiseResultTraits0::CallFactoryThenPromise(
                       &f0, std::move(r0));
               if (!Types::PromiseResultTraits1::IsOk(r1)) {
                 return Types::PromiseResultTraits1::template ReturnValue<
                     typename Types::Result>(std::move(r1));
               }
               typename Types::PromiseResult2 r2 =
                   Types::PromiseResultTraits1::CallFactoryThenPromise(
                       &f1, std::move(r1));
               if (!Types::PromiseResultTraits2::IsOk(r2)) {
                 return Types::PromiseResultTraits2::template ReturnValue<
                     typename Types::Result>(std::move(r2));
               }
               typename Types::PromiseResult3 r3 =
                   Types::PromiseResultTraits2::CallFactoryThenPromise(
                       &f2, std::move(r2));
               if (!Types::PromiseResultTraits3::IsOk(r3)) {
                 return Types::PromiseResultTraits3::template ReturnValue<
                     typename Types::Result>(std::move(r3));
               }
               typename Types::PromiseResult4 r4 =
                   Types::PromiseResultTraits3::CallFactoryThenPromise(
                       &f3, std::move(r3));
               if (!Types::PromiseResultTraits4::IsOk(r4)) {
                 return Types::PromiseResultTraits4::template ReturnValue<
                     typename Types::Result>(std::move(r4));
               }
               typename Types::PromiseResult5 r5 =
                   Types::PromiseResultTraits4::CallFactoryThenPromise(
                       &f4, std::move(r4));
               if (!Types::PromiseResultTraits5::IsOk(r5)) {
                 return Types::PromiseResultTraits5::template ReturnValue<
                     typename Types::Result>(std::move(r5));
               }
               typename Types::PromiseResult6 r6 =
                   Types::PromiseResultTraits5::CallFactoryThenPromise(
                       &f5, std::move(r5));
               if (!Types::PromiseResultTraits6::IsOk(r6)) {
                 return Types::PromiseResultTraits6::template ReturnValue<
                     typename Types::Result>(std::move(r6));
               }
               typename Types::PromiseResult7 r7 =
                   Types::PromiseResultTraits6::CallFactoryThenPromise(
                       &f6, std::move(r6));
               if (!Types::PromiseResultTraits7::IsOk(r7)) {
                 return Types::PromiseResultTraits7::template ReturnValue<
                     typename Types::Result>(std::move(r7));
               }
               typename Types::PromiseResult8 r8 =
                   Types::PromiseResultTraits7::CallFactoryThenPromise(
                       &f7, std::move(r7));
               if (!Types::PromiseResultTraits8::IsOk(r8)) {
                 return Types::PromiseResultTraits8::template ReturnValue<
                     typename Types::Result>(std::move(r8));
               }
               typename Types::PromiseResult9 r9 =
                   Types::PromiseResultTraits8::CallFactoryThenPromise(
                       &f8, std::move(r8));
               if (!Types::PromiseResultTraits9::IsOk(r9)) {
                 return Types::PromiseResultTraits9::template ReturnValue<
                     typename Types::Result>(std::move(r9));
               }
               typename Types::PromiseResult10 r10 =
                   Types::PromiseResultTraits9::CallFactoryThenPromise(
                       &f9, std::move(r9));
               if (!Types::PromiseResultTraits10::IsOk(r10)) {
                 return Types::PromiseResultTraits10::template ReturnValue<
                     typename Types::Result>(std::move(r10));
               }
               typename Types::PromiseResult11 r11 =
                   Types::PromiseResultTraits10::CallFactoryThenPromise(
                       &f10, std::move(r10));
               if (!Types::PromiseResultTraits11::IsOk(r11)) {
                 return Types::PromiseResultTraits11::template ReturnValue<
                     typename Types::Result>(std::move(r11));
               }
               return typename Types::Result(
                   Types::PromiseResultTraits11::CallFactoryThenPromise(
                       &f11, std::move(r11)));
             });
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return
        [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1)](Arg x) mutable {
          OncePromiseFactory<decltype(x), F0> next(std::move(f0));
          return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1));
        };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                            std::move(f2));
    };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return
        [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
         f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3)](Arg x) mutable {
          OncePromiseFactory<decltype(x), F0> next(std::move(f0));
          return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                                std::move(f2), std::move(f3));
        };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3,
                                                        F4&& f4) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                            std::move(f2), std::move(f3), std::move(f4));
    };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3,
                                                        F4&& f4, F5&& f5) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return
        [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
         f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
         f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5)](Arg x) mutable {
          OncePromiseFactory<decltype(x), F0> next(std::move(f0));
          return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                                std::move(f2), std::move(f3), std::move(f4),
                                std::move(f5));
        };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4), std::move(f5));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3,
                                                        F4&& f4, F5&& f5,
                                                        F6&& f6) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                            std::move(f2), std::move(f3), std::move(f4),
                            std::move(f5), std::move(f6));
    };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4), std::move(f5),
                            std::move(f6));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3,
                                                        F4&& f4, F5&& f5,
                                                        F6&& f6, F7&& f7) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return
        [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
         f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
         f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
         f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7)](Arg x) mutable {
          OncePromiseFactory<decltype(x), F0> next(std::move(f0));
          return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                                std::move(f2), std::move(f3), std::move(f4),
                                std::move(f5), std::move(f6), std::move(f7));
        };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4), std::move(f5),
                            std::move(f6), std::move(f7));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3,
                                                        F4&& f4, F5&& f5,
                                                        F6&& f6, F7&& f7,
                                                        F8&& f8) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
            f8 = std::forward<F8>(f8)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                            std::move(f2), std::move(f3), std::move(f4),
                            std::move(f5), std::move(f6), std::move(f7),
                            std::move(f8));
    };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
            f8 = std::forward<F8>(f8)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4), std::move(f5),
                            std::move(f6), std::move(f7), std::move(f8));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0, F1&& f1,
                                                        F2&& f2, F3&& f3,
                                                        F4&& f4, F5&& f5,
                                                        F6&& f6, F7&& f7,
                                                        F8&& f8, F9&& f9) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return
        [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
         f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
         f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
         f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
         f8 = std::forward<F8>(f8), f9 = std::forward<F9>(f9)](Arg x) mutable {
          OncePromiseFactory<decltype(x), F0> next(std::move(f0));
          return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                                std::move(f2), std::move(f3), std::move(f4),
                                std::move(f5), std::move(f6), std::move(f7),
                                std::move(f8), std::move(f9));
        };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
            f8 = std::forward<F8>(f8), f9 = std::forward<F9>(f9)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4), std::move(f5),
                            std::move(f6), std::move(f7), std::move(f8),
                            std::move(f9));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(
    F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7,
    F8&& f8, F9&& f9, F10&& f10) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
            f8 = std::forward<F8>(f8), f9 = std::forward<F9>(f9),
            f10 = std::forward<F10>(f10)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(std::move(x)), std::move(f1),
                            std::move(f2), std::move(f3), std::move(f4),
                            std::move(f5), std::move(f6), std::move(f7),
                            std::move(f8), std::move(f9), std::move(f10));
    };
  } else {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
            f8 = std::forward<F8>(f8), f9 = std::forward<F9>(f9),
            f10 = std::forward<F10>(f10)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                            std::move(f3), std::move(f4), std::move(f5),
                            std::move(f6), std::move(f7), std::move(f8),
                            std::move(f9), std::move(f10));
    };
  }
}

template <template <typename> class Traits, typename Arg, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10,
          typename F11>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(
    F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7,
    F8&& f8, F9&& f9, F10&& f10, F11&& f11) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
            f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
            f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
            f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
            f8 = std::forward<F8>(f8), f9 = std::forward<F9>(f9),
            f10 = std::forward<F10>(f10),
            f11 = std::forward<F11>(f11)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return SeqMap<Traits>(
          next.Make(std::move(x)), std::move(f1), std::move(f2), std::move(f3),
          std::move(f4), std::move(f5), std::move(f6), std::move(f7),
          std::move(f8), std::move(f9), std::move(f10), std::move(f11));
    };
  } else {
    return
        [f0 = std::forward<F0>(f0), f1 = std::forward<F1>(f1),
         f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
         f4 = std::forward<F4>(f4), f5 = std::forward<F5>(f5),
         f6 = std::forward<F6>(f6), f7 = std::forward<F7>(f7),
         f8 = std::forward<F8>(f8), f9 = std::forward<F9>(f9),
         f10 = std::forward<F10>(f10), f11 = std::forward<F11>(f11)]() mutable {
          OncePromiseFactory<void, F0> next(std::move(f0));
          return SeqMap<Traits>(next.Make(), std::move(f1), std::move(f2),
                                std::move(f3), std::move(f4), std::move(f5),
                                std::move(f6), std::move(f7), std::move(f8),
                                std::move(f9), std::move(f10), std::move(f11));
        };
  }
}

template <template <typename> class Traits, typename Arg, typename F0>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto SeqFactoryMap(F0&& f0) {
  if constexpr (!std::is_same_v<Arg, void>) {
    return [f0 = std::forward<F0>(f0)](Arg x) mutable {
      OncePromiseFactory<decltype(x), F0> next(std::move(f0));
      return next.Make(std::move(x));
    };
  } else {
    return [f0 = std::forward<F0>(f0)]() mutable {
      OncePromiseFactory<void, F0> next(std::move(f0));
      return next.Make();
    };
  }
}

template <template <typename> class Traits, typename P, typename... F>
using SeqMapType =
    decltype(SeqMap<Traits>(std::declval<P>(), std::declval<F>()...));
template <template <typename> class Traits, typename Arg, typename... F>
using SeqFactoryMapType =
    decltype(SeqFactoryMap<Traits, Arg>(std::declval<F>()...));
template <template <typename> class Traits, typename P, typename... Fs,
          size_t... Is>
auto FoldMiddleImpl(P&& p, std::tuple<Fs&&...>&& resolved,
                    std::index_sequence<Is...>, DebugLocation whence) {
  return SeqState<Traits, P, Fs...>(
      std::forward<P>(p), std::forward<Fs>(std::get<Is>(resolved))..., whence);
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Fs>
auto FoldMiddle(P&& p, std::tuple<Fs&&...>&& resolved, DebugLocation whence) {
  static_assert(kInstantBits == 0);
  return FoldMiddleImpl<Traits>(
      std::forward<P>(p), std::forward<std::tuple<Fs&&...>>(resolved),
      std::make_index_sequence<sizeof...(Fs)>(), whence);
}

template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0,
                DebugLocation whence) {
  static_assert((kInstantBits & 0b1) == 0);
  return FoldMiddle<Traits, 0>(
      std::forward<P>(p),
      std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                     std::tuple<F0&&>(std::forward<F0>(f0))),
      whence);
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0>;
  // i=1 mask=0b1
  if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)));
  } else {
    static_assert((kInstantBits & 0b1) == 0);
    return FoldMiddle<Traits, kInstantBits>(std::forward<P>(p), std::tuple<>(),
                                            std::forward<F0>(f0), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(std::forward<P>(p),
                                             std::forward<F0>(f0), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                DebugLocation whence) {
  static_assert((kInstantBits & 0b10) == 0);
  // i=1 mask=0b1 not_mask=0b0
  if constexpr ((kInstantBits & 0b1) == 0b1) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(
            std::forward<std::tuple<Rs&&...>>(resolved),
            std::tuple<F0&&, F1&&>(std::forward<F0>(f0), std::forward<F1>(f1))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1>;
  // i=2 mask=0b11
  if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
                           std::forward<P>(p), std::forward<F0>(f0), whence),
                       std::forward<F1>(f1)));
  }
  // i=1 mask=0b10 not_mask=0b1
  else if constexpr ((kInstantBits & 0b10) == 0b10) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), whence));
  } else {
    static_assert((kInstantBits & 0b10) == 0);
    return FoldMiddle<Traits, kInstantBits>(std::forward<P>(p), std::tuple<>(),
                                            std::forward<F0>(f0),
                                            std::forward<F1>(f1), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(std::forward<P>(p),
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, DebugLocation whence) {
  static_assert((kInstantBits & 0b100) == 0);
  // i=2 mask=0b11 not_mask=0b0
  if constexpr ((kInstantBits & 0b11) == 0b11) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        whence);
  }
  // i=1 mask=0b10 not_mask=0b1
  else if constexpr ((kInstantBits & 0b10) == 0b10) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<F0&&, F1&&, F2&&>(std::forward<F0>(f0),
                                                    std::forward<F1>(f1),
                                                    std::forward<F2>(f2))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2>;
  // i=3 mask=0b111
  if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                       std::forward<F1>(f1), std::forward<F2>(f2)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
                           std::forward<P>(p), std::forward<F0>(f0), whence),
                       std::forward<F1>(f1), std::forward<F2>(f2)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), whence),
                       std::forward<F2>(f2)));
  }
  // i=2 mask=0b110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b110) == 0b110) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), whence));
  }
  // i=1 mask=0b100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b100) == 0b100) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), whence));
  } else {
    static_assert((kInstantBits & 0b100) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       F2&& f2,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, DebugLocation whence) {
  static_assert((kInstantBits & 0b1000) == 0);
  // i=3 mask=0b111 not_mask=0b0
  if constexpr ((kInstantBits & 0b111) == 0b111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        whence);
  }
  // i=2 mask=0b110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b110) == 0b110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), whence);
  }
  // i=1 mask=0b100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b100) == 0b100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<F0&&, F1&&, F2&&, F3&&>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3>;
  // i=4 mask=0b1111
  if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), whence),
                       std::forward<F2>(f2), std::forward<F3>(f3)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2), whence),
                       std::forward<F3>(f3)));
  }
  // i=3 mask=0b1110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b1110) == 0b1110) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), whence));
  }
  // i=2 mask=0b1100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b1100) == 0b1100) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), whence));
  }
  // i=1 mask=0b1000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b1000) == 0b1000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            whence));
  } else {
    static_assert((kInstantBits & 0b1000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       F2&& f2, F3&& f3,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, DebugLocation whence) {
  static_assert((kInstantBits & 0b10000) == 0);
  // i=4 mask=0b1111 not_mask=0b0
  if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        whence);
  }
  // i=3 mask=0b1110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b1110) == 0b1110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), whence);
  }
  // i=2 mask=0b1100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b1100) == 0b1100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), whence);
  }
  // i=1 mask=0b1000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b1000) == 0b1000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>;
  // i=5 mask=0b11111
  if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
                           std::forward<P>(p), std::forward<F0>(f0), whence),
                       std::forward<F1>(f1), std::forward<F2>(f2),
                       std::forward<F3>(f3), std::forward<F4>(f4)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2), whence),
                       std::forward<F3>(f3), std::forward<F4>(f4)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4)));
  }
  // i=4 mask=0b11110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b11110) == 0b11110) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), whence));
  }
  // i=3 mask=0b11100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b11100) == 0b11100) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), whence));
  }
  // i=2 mask=0b11000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b11000) == 0b11000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            whence));
  }
  // i=1 mask=0b10000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b10000) == 0b10000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), whence));
  } else {
    static_assert((kInstantBits & 0b10000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       F2&& f2, F3&& f3,
                                                       F4&& f4,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, DebugLocation whence) {
  static_assert((kInstantBits & 0b100000) == 0);
  // i=5 mask=0b11111 not_mask=0b0
  if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        whence);
  }
  // i=4 mask=0b11110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b11110) == 0b11110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), whence);
  }
  // i=3 mask=0b11100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b11100) == 0b11100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), whence);
  }
  // i=2 mask=0b11000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b11000) == 0b11000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        whence);
  }
  // i=1 mask=0b10000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b10000) == 0b10000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5,
    DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>;
  // i=6 mask=0b111111
  if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), whence),
                       std::forward<F2>(f2), std::forward<F3>(f3),
                       std::forward<F4>(f4), std::forward<F5>(f5)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), whence),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4), whence),
                       std::forward<F5>(f5)));
  }
  // i=5 mask=0b111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b111110) == 0b111110) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), whence));
  }
  // i=4 mask=0b111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b111100) == 0b111100) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), whence));
  }
  // i=3 mask=0b111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b111000) == 0b111000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            whence));
  }
  // i=2 mask=0b110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b110000) == 0b110000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence));
  }
  // i=1 mask=0b100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b100000) == 0b100000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), whence));
  } else {
    static_assert((kInstantBits & 0b100000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       F2&& f2, F3&& f3,
                                                       F4&& f4, F5&& f5,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5, typename F6>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
                DebugLocation whence) {
  static_assert((kInstantBits & 0b1000000) == 0);
  // i=6 mask=0b111111 not_mask=0b0
  if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))),
        whence);
  }
  // i=5 mask=0b111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b111110) == 0b111110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        std::forward<F6>(f6), whence);
  }
  // i=4 mask=0b111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b111100) == 0b111100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), std::forward<F6>(f6), whence);
  }
  // i=3 mask=0b111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b111000) == 0b111000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        whence);
  }
  // i=2 mask=0b110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b110000) == 0b110000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), whence);
  }
  // i=1 mask=0b100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b100000) == 0b100000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&, F6&&>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5, typename F6>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6>;
  // i=7 mask=0b1111111
  if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6)));
  }
  // i=6 mask=0b111111
  else if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 6)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2), whence),
                       std::forward<F3>(f3), std::forward<F4>(f4),
                       std::forward<F5>(f5), std::forward<F6>(f6)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4), whence),
                       std::forward<F5>(f5), std::forward<F6>(f6)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence),
        std::forward<F6>(f6)));
  }
  // i=6 mask=0b1111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b1111110) == 0b1111110) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5)),
            std::forward<F6>(f6), whence));
  }
  // i=5 mask=0b1111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b1111100) == 0b1111100) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), std::forward<F6>(f6), whence));
  }
  // i=4 mask=0b1111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b1111000) == 0b1111000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            whence));
  }
  // i=3 mask=0b1110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b1110000) == 0b1110000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            std::forward<F6>(f6), whence));
  }
  // i=2 mask=0b1100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b1100000) == 0b1100000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), whence));
  }
  // i=1 mask=0b1000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b1000000) == 0b1000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            whence));
  } else {
    static_assert((kInstantBits & 0b1000000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       F2&& f2, F3&& f3,
                                                       F4&& f4, F5&& f5,
                                                       F6&& f6,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 64 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory6::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), std::forward<F6>(f6), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5, typename F6, typename F7>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7,
                DebugLocation whence) {
  static_assert((kInstantBits & 0b10000000) == 0);
  // i=7 mask=0b1111111 not_mask=0b0
  if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6),
                          std::forward<F7>(f7)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7)))),
        whence);
  }
  // i=6 mask=0b1111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b1111110) == 0b1111110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))),
        std::forward<F7>(f7), whence);
  }
  // i=5 mask=0b1111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b1111100) == 0b1111100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        std::forward<F6>(f6), std::forward<F7>(f7), whence);
  }
  // i=4 mask=0b1111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b1111000) == 0b1111000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        whence);
  }
  // i=3 mask=0b1110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b1110000) == 0b1110000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), whence);
  }
  // i=2 mask=0b1100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b1100000) == 0b1100000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), whence);
  }
  // i=1 mask=0b1000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b1000000) == 0b1000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(
            std::forward<std::tuple<Rs&&...>>(resolved),
            std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&, F6&&, F7&&>(
                std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5, typename F6, typename F7>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7>;
  // i=8 mask=0b11111111
  if constexpr ((kInstantBits & 0b11111111) == 0b11111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)));
  }
  // i=7 mask=0b1111111
  else if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 7)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7)));
  }
  // i=6 mask=0b111111
  else if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 6)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), whence),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            whence),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence),
        std::forward<F6>(f6), std::forward<F7>(f7)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), whence),
        std::forward<F7>(f7)));
  }
  // i=7 mask=0b11111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b11111110) == 0b11111110) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5,
                                         F6>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6)),
            std::forward<F7>(f7), whence));
  }
  // i=6 mask=0b11111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b11111100) == 0b11111100) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5)),
            std::forward<F6>(f6), std::forward<F7>(f7), whence));
  }
  // i=5 mask=0b11111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b11111000) == 0b11111000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            whence));
  }
  // i=4 mask=0b11110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b11110000) == 0b11110000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), whence));
  }
  // i=3 mask=0b11100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b11100000) == 0b11100000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            std::forward<F6>(f6), std::forward<F7>(f7), whence));
  }
  // i=2 mask=0b11000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b11000000) == 0b11000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            whence));
  }
  // i=1 mask=0b10000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b10000000) == 0b10000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), whence));
  } else {
    static_assert((kInstantBits & 0b10000000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(P&& p, F0&& f0, F1&& f1,
                                                       F2&& f2, F3&& f3,
                                                       F4&& f4, F5&& f5,
                                                       F6&& f6, F7&& f7,
                                                       DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 128 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 64 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory6::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory7::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
          whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5, typename F6, typename F7, typename F8>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8,
                DebugLocation whence) {
  static_assert((kInstantBits & 0b100000000) == 0);
  // i=8 mask=0b11111111 not_mask=0b0
  if constexpr ((kInstantBits & 0b11111111) == 0b11111111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6, F7, F8>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))),
        whence);
  }
  // i=7 mask=0b11111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b11111110) == 0b11111110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6),
                          std::forward<F7>(f7)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7)))),
        std::forward<F8>(f8), whence);
  }
  // i=6 mask=0b11111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b11111100) == 0b11111100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))),
        std::forward<F7>(f7), std::forward<F8>(f8), whence);
  }
  // i=5 mask=0b11111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b11111000) == 0b11111000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        whence);
  }
  // i=4 mask=0b11110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b11110000) == 0b11110000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), whence);
  }
  // i=3 mask=0b11100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b11100000) == 0b11100000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), whence);
  }
  // i=2 mask=0b11000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b11000000) == 0b11000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        whence);
  }
  // i=1 mask=0b10000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b10000000) == 0b10000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(
            std::forward<std::tuple<Rs&&...>>(resolved),
            std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&, F6&&, F7&&, F8&&>(
                std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7),
                std::forward<F8>(f8))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5, typename F6, typename F7, typename F8>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8>;
  // i=9 mask=0b111111111
  if constexpr ((kInstantBits & 0b111111111) == 0b111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8)));
  }
  // i=8 mask=0b11111111
  else if constexpr ((kInstantBits & 0b11111111) == 0b11111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 8)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8)));
  }
  // i=7 mask=0b1111111
  else if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 7)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8)));
  }
  // i=6 mask=0b111111
  else if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 6)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), whence),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(
        SeqMap<Traits>(FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4), whence),
                       std::forward<F5>(f5), std::forward<F6>(f6),
                       std::forward<F7>(f7), std::forward<F8>(f8)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), whence),
        std::forward<F7>(f7), std::forward<F8>(f8)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            whence),
        std::forward<F8>(f8)));
  }
  // i=8 mask=0b111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b111111110) == 0b111111110) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                   F7>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7)),
            std::forward<F8>(f8), whence));
  }
  // i=7 mask=0b111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b111111100) == 0b111111100) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5,
                                         F6>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6)),
            std::forward<F7>(f7), std::forward<F8>(f8), whence));
  }
  // i=6 mask=0b111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b111111000) == 0b111111000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5)),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            whence));
  }
  // i=5 mask=0b111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b111110000) == 0b111110000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), whence));
  }
  // i=4 mask=0b111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b111100000) == 0b111100000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), whence));
  }
  // i=3 mask=0b111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b111000000) == 0b111000000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            whence));
  }
  // i=2 mask=0b110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b110000000) == 0b110000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), whence));
  }
  // i=1 mask=0b100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b100000000) == 0b100000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), whence));
  } else {
    static_assert((kInstantBits & 0b100000000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 256 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 128 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 64 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory6::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory7::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory8::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
          std::forward<F8>(f8), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5, typename F6, typename F7, typename F8,
          typename F9>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8,
                F9&& f9, DebugLocation whence) {
  static_assert((kInstantBits & 0b1000000000) == 0);
  // i=9 mask=0b111111111 not_mask=0b0
  if constexpr ((kInstantBits & 0b111111111) == 0b111111111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8),
                    std::forward<F9>(f9)))>::LastPromiseResult,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8), std::forward<F9>(f9)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8, F9>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8), std::forward<F9>(f9)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8), std::forward<F9>(f9)))),
        whence);
  }
  // i=8 mask=0b111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b111111110) == 0b111111110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6, F7, F8>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))),
        std::forward<F9>(f9), whence);
  }
  // i=7 mask=0b111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b111111100) == 0b111111100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6),
                          std::forward<F7>(f7)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7)))),
        std::forward<F8>(f8), std::forward<F9>(f9), whence);
  }
  // i=6 mask=0b111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b111111000) == 0b111111000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        whence);
  }
  // i=5 mask=0b111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b111110000) == 0b111110000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), whence);
  }
  // i=4 mask=0b111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b111100000) == 0b111100000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), whence);
  }
  // i=3 mask=0b111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b111000000) == 0b111000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        whence);
  }
  // i=2 mask=0b110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b110000000) == 0b110000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), whence);
  }
  // i=1 mask=0b100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b100000000) == 0b100000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(
            std::forward<std::tuple<Rs&&...>>(resolved),
            std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&, F6&&, F7&&, F8&&,
                       F9&&>(std::forward<F0>(f0), std::forward<F1>(f1),
                             std::forward<F2>(f2), std::forward<F3>(f3),
                             std::forward<F4>(f4), std::forward<F5>(f5),
                             std::forward<F6>(f6), std::forward<F7>(f7),
                             std::forward<F8>(f8), std::forward<F9>(f9))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5, typename F6, typename F7, typename F8, typename F9>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, F9&& f9, DebugLocation whence) {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9>;
  // i=10 mask=0b1111111111
  if constexpr ((kInstantBits & 0b1111111111) == 0b1111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=9 mask=0b111111111
  else if constexpr ((kInstantBits & 0b111111111) == 0b111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 9)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=8 mask=0b11111111
  else if constexpr ((kInstantBits & 0b11111111) == 0b11111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 8)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=7 mask=0b1111111
  else if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 7)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), whence),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9)));
  }
  // i=6 mask=0b111111
  else if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 6)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            whence),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), whence),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            whence),
        std::forward<F8>(f8), std::forward<F9>(f9)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), whence),
        std::forward<F9>(f9)));
  }
  // i=9 mask=0b1111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b1111111110) == 0b1111111110) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6),
                      std::forward<F7>(f7), std::forward<F8>(f8)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                         F7, F8>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7), std::forward<F8>(f8)),
            std::forward<F9>(f9), whence));
  }
  // i=8 mask=0b1111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b1111111100) == 0b1111111100) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                   F7>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7)),
            std::forward<F8>(f8), std::forward<F9>(f9), whence));
  }
  // i=7 mask=0b1111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b1111111000) == 0b1111111000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5,
                                         F6>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6)),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            whence));
  }
  // i=6 mask=0b1111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b1111110000) == 0b1111110000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5)),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            std::forward<F9>(f9), whence));
  }
  // i=5 mask=0b1111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b1111100000) == 0b1111100000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), whence));
  }
  // i=4 mask=0b1111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b1111000000) == 0b1111000000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            whence));
  }
  // i=3 mask=0b1110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b1110000000) == 0b1110000000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            std::forward<F9>(f9), whence));
  }
  // i=2 mask=0b1100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b1100000000) == 0b1100000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), whence));
  }
  // i=1 mask=0b1000000000 not_mask=0b111111111
  else if constexpr ((kInstantBits & 0b1000000000) == 0b1000000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            whence));
  } else {
    static_assert((kInstantBits & 0b1000000000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, F9&& f9, DebugLocation whence) {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 512 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 256 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 128 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 64 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory6::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory7::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory8::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory9::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
          std::forward<F8>(f8), std::forward<F9>(f9), whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5, typename F6, typename F7, typename F8,
          typename F9, typename F10>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8,
                F9&& f9, F10&& f10, DebugLocation whence) {
  static_assert((kInstantBits & 0b10000000000) == 0);
  // i=10 mask=0b1111111111 not_mask=0b0
  if constexpr ((kInstantBits & 0b1111111111) == 0b1111111111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8), std::forward<F9>(f9),
                    std::forward<F10>(f10)))>::LastPromiseResult,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9, F10>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8), std::forward<F9>(f9),
                          std::forward<F10>(f10)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8, F9, F10>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8), std::forward<F9>(f9),
                           std::forward<F10>(f10)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8), std::forward<F9>(f9),
                               std::forward<F10>(f10)))),
        whence);
  }
  // i=9 mask=0b1111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b1111111110) == 0b1111111110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8),
                    std::forward<F9>(f9)))>::LastPromiseResult,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8), std::forward<F9>(f9)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8, F9>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8), std::forward<F9>(f9)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8), std::forward<F9>(f9)))),
        std::forward<F10>(f10), whence);
  }
  // i=8 mask=0b1111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b1111111100) == 0b1111111100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6, F7, F8>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))),
        std::forward<F9>(f9), std::forward<F10>(f10), whence);
  }
  // i=7 mask=0b1111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b1111111000) == 0b1111111000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6),
                          std::forward<F7>(f7)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7)))),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        whence);
  }
  // i=6 mask=0b1111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b1111110000) == 0b1111110000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), whence);
  }
  // i=5 mask=0b1111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b1111100000) == 0b1111100000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10), whence);
  }
  // i=4 mask=0b1111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b1111000000) == 0b1111000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        whence);
  }
  // i=3 mask=0b1110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b1110000000) == 0b1110000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), whence);
  }
  // i=2 mask=0b1100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b1100000000) == 0b1100000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10), whence);
  }
  // i=1 mask=0b1000000000 not_mask=0b111111111
  else if constexpr ((kInstantBits & 0b1000000000) == 0b1000000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(
            std::forward<std::tuple<Rs&&...>>(resolved),
            std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&, F6&&, F7&&, F8&&,
                       F9&&, F10&&>(std::forward<F0>(f0), std::forward<F1>(f1),
                                    std::forward<F2>(f2), std::forward<F3>(f3),
                                    std::forward<F4>(f4), std::forward<F5>(f5),
                                    std::forward<F6>(f6), std::forward<F7>(f7),
                                    std::forward<F8>(f8), std::forward<F9>(f9),
                                    std::forward<F10>(f10))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5, typename F6, typename F7, typename F8, typename F9,
          typename F10>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, F9&& f9, F10&& f10, DebugLocation whence) {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>;
  // i=11 mask=0b11111111111
  if constexpr ((kInstantBits & 0b11111111111) == 0b11111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=10 mask=0b1111111111
  else if constexpr ((kInstantBits & 0b1111111111) == 0b1111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 10)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10)));
  }
  // i=9 mask=0b111111111
  else if constexpr ((kInstantBits & 0b111111111) == 0b111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 9)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=8 mask=0b11111111
  else if constexpr ((kInstantBits & 0b11111111) == 0b11111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 8)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), whence),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=7 mask=0b1111111
  else if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 7)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10)));
  }
  // i=6 mask=0b111111
  else if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 6)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            whence),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), whence),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            whence),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), whence),
        std::forward<F9>(f9), std::forward<F10>(f10)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), whence),
        std::forward<F10>(f10)));
  }
  // i=10 mask=0b11111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b11111111110) == 0b11111111110) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7),
                std::forward<F8>(f8), std::forward<F9>(f9)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7,
                                   F8, F9>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7), std::forward<F8>(f8),
                           std::forward<F9>(f9)),
            std::forward<F10>(f10), whence));
  }
  // i=9 mask=0b11111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b11111111100) == 0b11111111100) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6),
                      std::forward<F7>(f7), std::forward<F8>(f8)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                         F7, F8>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7), std::forward<F8>(f8)),
            std::forward<F9>(f9), std::forward<F10>(f10), whence));
  }
  // i=8 mask=0b11111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b11111111000) == 0b11111111000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                   F7>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7)),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            whence));
  }
  // i=7 mask=0b11111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b11111110000) == 0b11111110000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5,
                                         F6>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6)),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            std::forward<F10>(f10), whence));
  }
  // i=6 mask=0b11111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b11111100000) == 0b11111100000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5)),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            std::forward<F9>(f9), std::forward<F10>(f10), whence));
  }
  // i=5 mask=0b11111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b11111000000) == 0b11111000000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            whence));
  }
  // i=4 mask=0b11110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b11110000000) == 0b11110000000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            std::forward<F10>(f10), whence));
  }
  // i=3 mask=0b11100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b11100000000) == 0b11100000000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            std::forward<F9>(f9), std::forward<F10>(f10), whence));
  }
  // i=2 mask=0b11000000000 not_mask=0b111111111
  else if constexpr ((kInstantBits & 0b11000000000) == 0b11000000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            whence));
  }
  // i=1 mask=0b10000000000 not_mask=0b1111111111
  else if constexpr ((kInstantBits & 0b10000000000) == 0b10000000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            std::forward<F10>(f10), whence));
  } else {
    static_assert((kInstantBits & 0b10000000000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, F9&& f9, F10&& f10, DebugLocation whence) {
  using Types =
      SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 1024 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 512 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 256 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 128 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 64 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory6::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory7::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory8::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory9::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory10::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
          std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
          whence));
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename... Rs, typename F0, typename F1, typename F2, typename F3,
          typename F4, typename F5, typename F6, typename F7, typename F8,
          typename F9, typename F10, typename F11>
auto FoldMiddle(P&& p, std::tuple<Rs&&...>&& resolved, F0&& f0, F1&& f1,
                F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8,
                F9&& f9, F10&& f10, F11&& f11, DebugLocation whence) {
  static_assert((kInstantBits & 0b100000000000) == 0);
  // i=11 mask=0b11111111111 not_mask=0b0
  if constexpr ((kInstantBits & 0b11111111111) == 0b11111111111) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8), std::forward<F9>(f9),
                    std::forward<F10>(f10),
                    std::forward<F11>(f11)))>::LastPromiseResult,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9, F10, F11>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8), std::forward<F9>(f9),
                    std::forward<F10>(f10), std::forward<F11>(f11)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9, F10, F11>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b0)>(
        std::forward<P>(p),
        std::tuple_cat(
            std::forward<std::tuple<Rs&&...>>(resolved),
            std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7),
                std::forward<F8>(f8), std::forward<F9>(f9),
                std::forward<F10>(f10), std::forward<F11>(f11)))&&>(
                SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8), std::forward<F9>(f9),
                    std::forward<F10>(f10), std::forward<F11>(f11)))),
        whence);
  }
  // i=10 mask=0b11111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b11111111110) == 0b11111111110) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8), std::forward<F9>(f9),
                    std::forward<F10>(f10)))>::LastPromiseResult,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9, F10>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8), std::forward<F9>(f9),
                          std::forward<F10>(f10)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8, F9, F10>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8), std::forward<F9>(f9),
                           std::forward<F10>(f10)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8), std::forward<F9>(f9),
                               std::forward<F10>(f10)))),
        std::forward<F11>(f11), whence);
  }
  // i=9 mask=0b11111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b11111111100) == 0b11111111100) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3),
                    std::forward<F4>(f4), std::forward<F5>(f5),
                    std::forward<F6>(f6), std::forward<F7>(f7),
                    std::forward<F8>(f8),
                    std::forward<F9>(f9)))>::LastPromiseResult,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4, F5, F6,
                                   F7, F8, F9>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8), std::forward<F9>(f9)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8, F9>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8), std::forward<F9>(f9)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8), std::forward<F9>(f9)))),
        std::forward<F10>(f10), std::forward<F11>(f11), whence);
  }
  // i=8 mask=0b11111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b11111111000) == 0b11111111000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7),
                          std::forward<F8>(f8)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7, F8>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6, F7, F8>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7),
                               std::forward<F8>(f8)))),
        std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11),
        whence);
  }
  // i=7 mask=0b11111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b11111110000) == 0b11111110000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6),
                          std::forward<F7>(f7)))>::LastPromiseResult,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5),
                          std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5, F6, F7>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6), std::forward<F7>(f7)))),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11), whence);
  }
  // i=6 mask=0b11111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b11111100000) == 0b11111100000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5, F6>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5),
                               std::forward<F6>(f6)))),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), std::forward<F11>(f11), whence);
  }
  // i=5 mask=0b11111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b11111000000) == 0b11111000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4),
                               std::forward<F5>(f5)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4, F5>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<
                      Traits, P, Rs...,
                      decltype(SeqFactoryMap<Traits, Arg>(
                          std::forward<F0>(f0), std::forward<F1>(f1),
                          std::forward<F2>(f2), std::forward<F3>(f3),
                          std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3, F4,
                                         F5>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4), std::forward<F5>(f5)))),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11),
        whence);
  }
  // i=4 mask=0b11110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b11110000000) == 0b11110000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::LastPromiseResult>);
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))>::Result,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3,
                                              F4>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3),
                               std::forward<F4>(f4)))),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11), whence);
  }
  // i=3 mask=0b11100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b11100000000) == 0b11100000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2),
                               std::forward<F3>(f3)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2,
                                              F3>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<
                Traits, P, Rs...,
                decltype(SeqFactoryMap<Traits, Arg>(
                    std::forward<F0>(f0), std::forward<F1>(f1),
                    std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2, F3>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b11111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3)))&&>(
                           SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2), std::forward<F3>(f3)))),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), std::forward<F11>(f11), whence);
  }
  // i=2 mask=0b11000000000 not_mask=0b111111111
  else if constexpr ((kInstantBits & 0b11000000000) == 0b11000000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0), std::forward<F1>(f1),
                               std::forward<F2>(f2)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0, F1,
                                              F2>::LastPromiseResult>);
    static_assert(
        std::is_same_v<
            typename SeqStateTypes<Traits, P, Rs...,
                                   decltype(SeqFactoryMap<Traits, Arg>(
                                       std::forward<F0>(f0),
                                       std::forward<F1>(f1),
                                       std::forward<F2>(f2)))>::Result,
            typename SeqStateTypes<Traits, P, Rs..., F0, F1, F2>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b111111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1),
                                                      std::forward<F2>(f2)))),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11),
        whence);
  }
  // i=1 mask=0b10000000000 not_mask=0b1111111111
  else if constexpr ((kInstantBits & 0b10000000000) == 0b10000000000) {
    using Arg = typename SeqStateTypes<Traits, P, Rs...>::LastPromiseResult;
    static_assert(
        std::is_same_v<typename SeqStateTypes<
                           Traits, P, Rs...,
                           decltype(SeqFactoryMap<Traits, Arg>(
                               std::forward<F0>(f0),
                               std::forward<F1>(f1)))>::LastPromiseResult,
                       typename SeqStateTypes<Traits, P, Rs..., F0,
                                              F1>::LastPromiseResult>);
    static_assert(std::is_same_v<
                  typename SeqStateTypes<Traits, P, Rs...,
                                         decltype(SeqFactoryMap<Traits, Arg>(
                                             std::forward<F0>(f0),
                                             std::forward<F1>(f1)))>::Result,
                  typename SeqStateTypes<Traits, P, Rs..., F0, F1>::Result>);
    return FoldMiddle<Traits, (kInstantBits & 0b1111111111)>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<decltype(SeqFactoryMap<Traits, Arg>(
                           std::forward<F0>(f0), std::forward<F1>(f1)))&&>(
                           SeqFactoryMap<Traits, Arg>(std::forward<F0>(f0),
                                                      std::forward<F1>(f1)))),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11), whence);
  } else {
    return FoldMiddle<Traits, 0>(
        std::forward<P>(p),
        std::tuple_cat(std::forward<std::tuple<Rs&&...>>(resolved),
                       std::tuple<F0&&, F1&&, F2&&, F3&&, F4&&, F5&&, F6&&,
                                  F7&&, F8&&, F9&&, F10&&, F11&&>(
                           std::forward<F0>(f0), std::forward<F1>(f1),
                           std::forward<F2>(f2), std::forward<F3>(f3),
                           std::forward<F4>(f4), std::forward<F5>(f5),
                           std::forward<F6>(f6), std::forward<F7>(f7),
                           std::forward<F8>(f8), std::forward<F9>(f9),
                           std::forward<F10>(f10), std::forward<F11>(f11))),
        whence);
  }
}
template <template <typename> class Traits, uint32_t kInstantBits, typename P,
          typename F0, typename F1, typename F2, typename F3, typename F4,
          typename F5, typename F6, typename F7, typename F8, typename F9,
          typename F10, typename F11>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqStateImpl(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9,
                              F10, F11>;
  // i=12 mask=0b111111111111
  if constexpr ((kInstantBits & 0b111111111111) == 0b111111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11)));
  }
  // i=11 mask=0b11111111111
  else if constexpr ((kInstantBits & 0b11111111111) == 0b11111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 11)>(
            std::forward<P>(p), std::forward<F0>(f0), whence),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=10 mask=0b1111111111
  else if constexpr ((kInstantBits & 0b1111111111) == 0b1111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 10)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            whence),
        std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11)));
  }
  // i=9 mask=0b111111111
  else if constexpr ((kInstantBits & 0b111111111) == 0b111111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 9)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), whence),
        std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=8 mask=0b11111111
  else if constexpr ((kInstantBits & 0b11111111) == 0b11111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 8)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), whence),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=7 mask=0b1111111
  else if constexpr ((kInstantBits & 0b1111111) == 0b1111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 7)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            whence),
        std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11)));
  }
  // i=6 mask=0b111111
  else if constexpr ((kInstantBits & 0b111111) == 0b111111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 6)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), whence),
        std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
        std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=5 mask=0b11111
  else if constexpr ((kInstantBits & 0b11111) == 0b11111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 5)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), whence),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=4 mask=0b1111
  else if constexpr ((kInstantBits & 0b1111) == 0b1111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 4)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            whence),
        std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
        std::forward<F11>(f11)));
  }
  // i=3 mask=0b111
  else if constexpr ((kInstantBits & 0b111) == 0b111) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 3)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), whence),
        std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=2 mask=0b11
  else if constexpr ((kInstantBits & 0b11) == 0b11) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 2)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), whence),
        std::forward<F10>(f10), std::forward<F11>(f11)));
  }
  // i=1 mask=0b1
  else if constexpr ((kInstantBits & 0b1) == 0b1) {
    return WithResult<typename Types::Result>(SeqMap<Traits>(
        FoldSeqStateImpl<Traits, (kInstantBits >> 1)>(
            std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            whence),
        std::forward<F11>(f11)));
  }
  // i=11 mask=0b111111111110 not_mask=0b1
  else if constexpr ((kInstantBits & 0b111111111110) == 0b111111111110) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6),
                      std::forward<F7>(f7), std::forward<F8>(f8),
                      std::forward<F9>(f9), std::forward<F10>(f10)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                         F7, F8, F9, F10>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7), std::forward<F8>(f8),
                           std::forward<F9>(f9), std::forward<F10>(f10)),
            std::forward<F11>(f11), whence));
  }
  // i=10 mask=0b111111111100 not_mask=0b11
  else if constexpr ((kInstantBits & 0b111111111100) == 0b111111111100) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7),
                std::forward<F8>(f8), std::forward<F9>(f9)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7,
                                   F8, F9>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7), std::forward<F8>(f8),
                           std::forward<F9>(f9)),
            std::forward<F10>(f10), std::forward<F11>(f11), whence));
  }
  // i=9 mask=0b111111111000 not_mask=0b111
  else if constexpr ((kInstantBits & 0b111111111000) == 0b111111111000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6),
                      std::forward<F7>(f7), std::forward<F8>(f8)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                         F7, F8>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7), std::forward<F8>(f8)),
            std::forward<F9>(f9), std::forward<F10>(f10),
            std::forward<F11>(f11), whence));
  }
  // i=8 mask=0b111111110000 not_mask=0b1111
  else if constexpr ((kInstantBits & 0b111111110000) == 0b111111110000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5),
                std::forward<F6>(f6), std::forward<F7>(f7)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6,
                                   F7>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6),
                           std::forward<F7>(f7)),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            std::forward<F11>(f11), whence));
  }
  // i=7 mask=0b111111100000 not_mask=0b11111
  else if constexpr ((kInstantBits & 0b111111100000) == 0b111111100000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2),
                      std::forward<F3>(f3), std::forward<F4>(f4),
                      std::forward<F5>(f5), std::forward<F6>(f6)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5,
                                         F6>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5), std::forward<F6>(f6)),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            std::forward<F10>(f10), std::forward<F11>(f11), whence));
  }
  // i=6 mask=0b111111000000 not_mask=0b111111
  else if constexpr ((kInstantBits & 0b111111000000) == 0b111111000000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4), std::forward<F5>(f5)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4),
                           std::forward<F5>(f5)),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            std::forward<F9>(f9), std::forward<F10>(f10),
            std::forward<F11>(f11), whence));
  }
  // i=5 mask=0b111110000000 not_mask=0b1111111
  else if constexpr ((kInstantBits & 0b111110000000) == 0b111110000000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3),
                std::forward<F4>(f4)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3, F4>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3), std::forward<F4>(f4)),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            std::forward<F11>(f11), whence));
  }
  // i=4 mask=0b111100000000 not_mask=0b11111111
  else if constexpr ((kInstantBits & 0b111100000000) == 0b111100000000) {
    static_assert(
        std::is_same_v<
            typename PromiseLike<decltype(SeqMap<Traits>(
                std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
                std::forward<F2>(f2), std::forward<F3>(f3)))>::Result,
            typename SeqStateTypes<Traits, P, F0, F1, F2, F3>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2),
                           std::forward<F3>(f3)),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            std::forward<F10>(f10), std::forward<F11>(f11), whence));
  }
  // i=3 mask=0b111000000000 not_mask=0b111111111
  else if constexpr ((kInstantBits & 0b111000000000) == 0b111000000000) {
    static_assert(std::is_same_v<
                  typename PromiseLike<decltype(SeqMap<Traits>(
                      std::forward<P>(p), std::forward<F0>(f0),
                      std::forward<F1>(f1), std::forward<F2>(f2)))>::Result,
                  typename SeqStateTypes<Traits, P, F0, F1, F2>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b111111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1), std::forward<F2>(f2)),
            std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5),
            std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8),
            std::forward<F9>(f9), std::forward<F10>(f10),
            std::forward<F11>(f11), whence));
  }
  // i=2 mask=0b110000000000 not_mask=0b1111111111
  else if constexpr ((kInstantBits & 0b110000000000) == 0b110000000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)))>::Result,
                       typename SeqStateTypes<Traits, P, F0, F1>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b1111111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0),
                           std::forward<F1>(f1)),
            std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
            std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
            std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
            std::forward<F11>(f11), whence));
  }
  // i=1 mask=0b100000000000 not_mask=0b11111111111
  else if constexpr ((kInstantBits & 0b100000000000) == 0b100000000000) {
    static_assert(
        std::is_same_v<typename PromiseLike<decltype(SeqMap<Traits>(
                           std::forward<P>(p), std::forward<F0>(f0)))>::Result,
                       typename SeqStateTypes<Traits, P, F0>::Result>);
    return WithResult<typename Types::Result>(
        FoldSeqStateImpl<Traits, (kInstantBits & 0b11111111111)>(
            SeqMap<Traits>(std::forward<P>(p), std::forward<F0>(f0)),
            std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
            std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
            std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
            std::forward<F10>(f10), std::forward<F11>(f11), whence));
  } else {
    static_assert((kInstantBits & 0b100000000000) == 0);
    return FoldMiddle<Traits, kInstantBits>(
        std::forward<P>(p), std::tuple<>(), std::forward<F0>(f0),
        std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3),
        std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6),
        std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9),
        std::forward<F10>(f10), std::forward<F11>(f11), whence);
  }
}
template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7, typename F8, typename F9, typename F10,
          typename F11>
GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION auto FoldSeqState(
    P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
    F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, DebugLocation whence) {
  using Types = SeqStateTypes<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9,
                              F10, F11>;
  static constexpr uint32_t kInstantBits =
      (Types::NextFactory0::kInstantaneousPromise ? 2048 : 0) |
      (Types::NextFactory1::kInstantaneousPromise ? 1024 : 0) |
      (Types::NextFactory2::kInstantaneousPromise ? 512 : 0) |
      (Types::NextFactory3::kInstantaneousPromise ? 256 : 0) |
      (Types::NextFactory4::kInstantaneousPromise ? 128 : 0) |
      (Types::NextFactory5::kInstantaneousPromise ? 64 : 0) |
      (Types::NextFactory6::kInstantaneousPromise ? 32 : 0) |
      (Types::NextFactory7::kInstantaneousPromise ? 16 : 0) |
      (Types::NextFactory8::kInstantaneousPromise ? 8 : 0) |
      (Types::NextFactory9::kInstantaneousPromise ? 4 : 0) |
      (Types::NextFactory10::kInstantaneousPromise ? 2 : 0) |
      (Types::NextFactory11::kInstantaneousPromise ? 1 : 0);
  return WithResult<typename Types::Result>(
      FoldSeqStateImpl<Traits, kInstantBits>(
          std::forward<P>(p), std::forward<F0>(f0), std::forward<F1>(f1),
          std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4),
          std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7),
          std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10),
          std::forward<F11>(f11), whence));
}

}  // namespace promise_detail
}  // namespace grpc_core

#endif  // GRPC_SRC_CORE_LIB_PROMISE_DETAIL_SEQ_STATE_H
