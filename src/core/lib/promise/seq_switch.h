/*
 * Copyright 2021 gRPC authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Automatically generated by tools/codegen/core/gen_seq_switch.py
 */

template <typename F0, typename F1> class Seq<F0, F1> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State0::Next::Promise;
  union {
    [[no_unique_address]] State0 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1) : prior_(std::move(f0), std::move(f1)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State0(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State0(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.f);
      goto fin0;
     case 1:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State0::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2> class Seq<F0, F1, F2> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State1::Next::Promise;
  union {
    [[no_unique_address]] State1 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2) : prior_(std::move(f0), std::move(f1), std::move(f2)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State1(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State1(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.f);
      goto fin1;
     case 2:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.next);
  fin1:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State1::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3> class Seq<F0, F1, F2, F3> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State2::Next::Promise;
  union {
    [[no_unique_address]] State2 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State2(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State2(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.f);
      goto fin2;
     case 3:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.next);
  fin2:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State2::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4> class Seq<F0, F1, F2, F3, F4> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State3::Next::Promise;
  union {
    [[no_unique_address]] State3 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State3(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State3(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.f);
      goto fin3;
     case 4:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.next);
  fin3:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State3::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5> class Seq<F0, F1, F2, F3, F4, F5> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State4::Next::Promise;
  union {
    [[no_unique_address]] State4 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State4(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State4(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.f);
      goto fin4;
     case 5:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.next);
  fin4:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State4::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> class Seq<F0, F1, F2, F3, F4, F5, F6> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State5::Next::Promise;
  union {
    [[no_unique_address]] State5 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State5(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State5(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.f);
      goto fin5;
     case 6:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.next);
  fin5:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State5::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7> class Seq<F0, F1, F2, F3, F4, F5, F6, F7> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State6::Next::Promise;
  union {
    [[no_unique_address]] State6 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State6(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State6(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.f);
      goto fin6;
     case 7:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.next);
  fin6:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State6::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State7::Next::Promise;
  union {
    [[no_unique_address]] State7 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State7(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State7(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.f);
      goto fin7;
     case 8:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.next);
  fin7:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State7::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State8::Next::Promise;
  union {
    [[no_unique_address]] State8 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State8(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State8(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.f);
      goto fin8;
     case 9:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.next);
  fin8:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State8::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State9::Next::Promise;
  union {
    [[no_unique_address]] State9 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State9(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State9(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.f);
      goto fin9;
     case 10:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.next);
  fin9:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State9::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State10::Next::Promise;
  union {
    [[no_unique_address]] State10 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State10(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State10(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.f);
      goto fin10;
     case 11:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.next);
  fin10:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State10::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State11::Next::Promise;
  union {
    [[no_unique_address]] State11 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State11(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State11(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.f);
      goto fin11;
     case 12:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.next);
  fin11:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State11::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State12::Next::Promise;
  union {
    [[no_unique_address]] State12 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State12(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State12(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.f);
      goto fin12;
     case 13:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.next);
  fin12:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State12::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State13::Next::Promise;
  union {
    [[no_unique_address]] State13 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State13(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State13(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.f);
      goto fin13;
     case 14:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.next);
  fin13:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State13::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State14::Next::Promise;
  union {
    [[no_unique_address]] State14 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State14(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State14(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.f);
      goto fin14;
     case 15:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.next);
  fin14:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State14::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State15::Next::Promise;
  union {
    [[no_unique_address]] State15 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State15(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State15(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.f);
      goto fin15;
     case 16:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.next);
  fin15:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State15::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State16::Next::Promise;
  union {
    [[no_unique_address]] State16 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State16(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State16(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.f);
      goto fin16;
     case 17:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.next);
  fin16:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State16::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State17::Next::Promise;
  union {
    [[no_unique_address]] State17 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State17(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State17(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.f);
      goto fin17;
     case 18:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.next);
  fin17:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State17::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State18::Next::Promise;
  union {
    [[no_unique_address]] State18 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State18(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State18(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.f);
      goto fin18;
     case 19:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.next);
  fin18:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State18::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State19::Next::Promise;
  union {
    [[no_unique_address]] State19 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State19(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State19(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.f);
      goto fin19;
     case 20:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.next);
  fin19:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State19::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State20::Next::Promise;
  union {
    [[no_unique_address]] State20 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State20(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State20(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.f);
      goto fin20;
     case 21:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.next);
  fin20:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State20::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State21::Next::Promise;
  union {
    [[no_unique_address]] State21 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State21(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State21(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.f);
      goto fin21;
     case 22:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.next);
  fin21:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State21::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State22::Next::Promise;
  union {
    [[no_unique_address]] State22 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State22(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State22(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.f);
      goto fin22;
     case 23:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.next);
  fin22:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State22::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State23::Next::Promise;
  union {
    [[no_unique_address]] State23 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State23(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State23(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.f);
      goto fin23;
     case 24:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.next);
  fin23:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State23::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State24::Next::Promise;
  union {
    [[no_unique_address]] State24 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State24(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State24(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.f);
      goto fin24;
     case 25:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.next);
  fin24:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State24::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25, typename F26> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  struct State25 {
    State25(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26) : next(std::forward<F26>(f26)) { new (&prior) State24(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25)); }
    State25(State25&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State25(const State25& other) : prior(other.prior), next(other.next) {}
    ~State25() = delete;
    using F = typename State24::Next::Promise;
    union {
      [[no_unique_address]] State24 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F26>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State25::Next::Promise;
  union {
    [[no_unique_address]] State25 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25, F26 f26) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25), std::move(f26)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State25(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State25(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.prior.f);
      goto fin24;
     case 25:
      Destruct(&prior_.f);
      goto fin25;
     case 26:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.prior.next);
  fin24:
    Destruct(&prior_.prior.next);
  fin25:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State25::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State25::Next::Promise(std::move(n));
      state_ = 26;
     }
     case 26:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25, typename F26, typename F27> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  struct State25 {
    State25(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26) : next(std::forward<F26>(f26)) { new (&prior) State24(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25)); }
    State25(State25&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State25(const State25& other) : prior(other.prior), next(other.next) {}
    ~State25() = delete;
    using F = typename State24::Next::Promise;
    union {
      [[no_unique_address]] State24 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F26>;
    [[no_unique_address]] Next next;
  };
  struct State26 {
    State26(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27) : next(std::forward<F27>(f27)) { new (&prior) State25(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26)); }
    State26(State26&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State26(const State26& other) : prior(other.prior), next(other.next) {}
    ~State26() = delete;
    using F = typename State25::Next::Promise;
    union {
      [[no_unique_address]] State25 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F27>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State26::Next::Promise;
  union {
    [[no_unique_address]] State26 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25, F26 f26, F27 f27) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25), std::move(f26), std::move(f27)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State26(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State26(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.prior.prior.f);
      goto fin24;
     case 25:
      Destruct(&prior_.prior.f);
      goto fin25;
     case 26:
      Destruct(&prior_.f);
      goto fin26;
     case 27:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.prior.prior.next);
  fin24:
    Destruct(&prior_.prior.prior.next);
  fin25:
    Destruct(&prior_.prior.next);
  fin26:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State26::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State25::Next::Promise(std::move(n));
      state_ = 26;
     }
     case 26: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State26::Next::Promise(std::move(n));
      state_ = 27;
     }
     case 27:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25, typename F26, typename F27, typename F28> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  struct State25 {
    State25(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26) : next(std::forward<F26>(f26)) { new (&prior) State24(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25)); }
    State25(State25&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State25(const State25& other) : prior(other.prior), next(other.next) {}
    ~State25() = delete;
    using F = typename State24::Next::Promise;
    union {
      [[no_unique_address]] State24 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F26>;
    [[no_unique_address]] Next next;
  };
  struct State26 {
    State26(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27) : next(std::forward<F27>(f27)) { new (&prior) State25(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26)); }
    State26(State26&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State26(const State26& other) : prior(other.prior), next(other.next) {}
    ~State26() = delete;
    using F = typename State25::Next::Promise;
    union {
      [[no_unique_address]] State25 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F27>;
    [[no_unique_address]] Next next;
  };
  struct State27 {
    State27(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28) : next(std::forward<F28>(f28)) { new (&prior) State26(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27)); }
    State27(State27&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State27(const State27& other) : prior(other.prior), next(other.next) {}
    ~State27() = delete;
    using F = typename State26::Next::Promise;
    union {
      [[no_unique_address]] State26 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F28>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State27::Next::Promise;
  union {
    [[no_unique_address]] State27 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25, F26 f26, F27 f27, F28 f28) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25), std::move(f26), std::move(f27), std::move(f28)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State27(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State27(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin24;
     case 25:
      Destruct(&prior_.prior.prior.f);
      goto fin25;
     case 26:
      Destruct(&prior_.prior.f);
      goto fin26;
     case 27:
      Destruct(&prior_.f);
      goto fin27;
     case 28:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin24:
    Destruct(&prior_.prior.prior.prior.next);
  fin25:
    Destruct(&prior_.prior.prior.next);
  fin26:
    Destruct(&prior_.prior.next);
  fin27:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State27::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State25::Next::Promise(std::move(n));
      state_ = 26;
     }
     case 26: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State26::Next::Promise(std::move(n));
      state_ = 27;
     }
     case 27: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State27::Next::Promise(std::move(n));
      state_ = 28;
     }
     case 28:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25, typename F26, typename F27, typename F28, typename F29> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28, F29> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  struct State25 {
    State25(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26) : next(std::forward<F26>(f26)) { new (&prior) State24(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25)); }
    State25(State25&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State25(const State25& other) : prior(other.prior), next(other.next) {}
    ~State25() = delete;
    using F = typename State24::Next::Promise;
    union {
      [[no_unique_address]] State24 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F26>;
    [[no_unique_address]] Next next;
  };
  struct State26 {
    State26(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27) : next(std::forward<F27>(f27)) { new (&prior) State25(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26)); }
    State26(State26&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State26(const State26& other) : prior(other.prior), next(other.next) {}
    ~State26() = delete;
    using F = typename State25::Next::Promise;
    union {
      [[no_unique_address]] State25 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F27>;
    [[no_unique_address]] Next next;
  };
  struct State27 {
    State27(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28) : next(std::forward<F28>(f28)) { new (&prior) State26(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27)); }
    State27(State27&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State27(const State27& other) : prior(other.prior), next(other.next) {}
    ~State27() = delete;
    using F = typename State26::Next::Promise;
    union {
      [[no_unique_address]] State26 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F28>;
    [[no_unique_address]] Next next;
  };
  struct State28 {
    State28(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28, F29&& f29) : next(std::forward<F29>(f29)) { new (&prior) State27(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27), std::forward<F28>(f28)); }
    State28(State28&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State28(const State28& other) : prior(other.prior), next(other.next) {}
    ~State28() = delete;
    using F = typename State27::Next::Promise;
    union {
      [[no_unique_address]] State27 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F29>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State28::Next::Promise;
  union {
    [[no_unique_address]] State28 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25, F26 f26, F27 f27, F28 f28, F29 f29) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25), std::move(f26), std::move(f27), std::move(f28), std::move(f29)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State28(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State28(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin24;
     case 25:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin25;
     case 26:
      Destruct(&prior_.prior.prior.f);
      goto fin26;
     case 27:
      Destruct(&prior_.prior.f);
      goto fin27;
     case 28:
      Destruct(&prior_.f);
      goto fin28;
     case 29:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin24:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin25:
    Destruct(&prior_.prior.prior.prior.next);
  fin26:
    Destruct(&prior_.prior.prior.next);
  fin27:
    Destruct(&prior_.prior.next);
  fin28:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State28::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State25::Next::Promise(std::move(n));
      state_ = 26;
     }
     case 26: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State26::Next::Promise(std::move(n));
      state_ = 27;
     }
     case 27: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State27::Next::Promise(std::move(n));
      state_ = 28;
     }
     case 28: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State28::Next::Promise(std::move(n));
      state_ = 29;
     }
     case 29:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25, typename F26, typename F27, typename F28, typename F29, typename F30> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28, F29, F30> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  struct State25 {
    State25(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26) : next(std::forward<F26>(f26)) { new (&prior) State24(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25)); }
    State25(State25&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State25(const State25& other) : prior(other.prior), next(other.next) {}
    ~State25() = delete;
    using F = typename State24::Next::Promise;
    union {
      [[no_unique_address]] State24 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F26>;
    [[no_unique_address]] Next next;
  };
  struct State26 {
    State26(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27) : next(std::forward<F27>(f27)) { new (&prior) State25(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26)); }
    State26(State26&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State26(const State26& other) : prior(other.prior), next(other.next) {}
    ~State26() = delete;
    using F = typename State25::Next::Promise;
    union {
      [[no_unique_address]] State25 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F27>;
    [[no_unique_address]] Next next;
  };
  struct State27 {
    State27(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28) : next(std::forward<F28>(f28)) { new (&prior) State26(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27)); }
    State27(State27&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State27(const State27& other) : prior(other.prior), next(other.next) {}
    ~State27() = delete;
    using F = typename State26::Next::Promise;
    union {
      [[no_unique_address]] State26 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F28>;
    [[no_unique_address]] Next next;
  };
  struct State28 {
    State28(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28, F29&& f29) : next(std::forward<F29>(f29)) { new (&prior) State27(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27), std::forward<F28>(f28)); }
    State28(State28&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State28(const State28& other) : prior(other.prior), next(other.next) {}
    ~State28() = delete;
    using F = typename State27::Next::Promise;
    union {
      [[no_unique_address]] State27 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F29>;
    [[no_unique_address]] Next next;
  };
  struct State29 {
    State29(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28, F29&& f29, F30&& f30) : next(std::forward<F30>(f30)) { new (&prior) State28(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27), std::forward<F28>(f28), std::forward<F29>(f29)); }
    State29(State29&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State29(const State29& other) : prior(other.prior), next(other.next) {}
    ~State29() = delete;
    using F = typename State28::Next::Promise;
    union {
      [[no_unique_address]] State28 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F30>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State29::Next::Promise;
  union {
    [[no_unique_address]] State29 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25, F26 f26, F27 f27, F28 f28, F29 f29, F30 f30) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25), std::move(f26), std::move(f27), std::move(f28), std::move(f29), std::move(f30)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State29(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State29(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin24;
     case 25:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin25;
     case 26:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin26;
     case 27:
      Destruct(&prior_.prior.prior.f);
      goto fin27;
     case 28:
      Destruct(&prior_.prior.f);
      goto fin28;
     case 29:
      Destruct(&prior_.f);
      goto fin29;
     case 30:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin24:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin25:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin26:
    Destruct(&prior_.prior.prior.prior.next);
  fin27:
    Destruct(&prior_.prior.prior.next);
  fin28:
    Destruct(&prior_.prior.next);
  fin29:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State29::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State25::Next::Promise(std::move(n));
      state_ = 26;
     }
     case 26: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State26::Next::Promise(std::move(n));
      state_ = 27;
     }
     case 27: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State27::Next::Promise(std::move(n));
      state_ = 28;
     }
     case 28: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State28::Next::Promise(std::move(n));
      state_ = 29;
     }
     case 29: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State29::Next::Promise(std::move(n));
      state_ = 30;
     }
     case 30:
      return f_();
    }
    return kPending;
  }
};
template <typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9, typename F10, typename F11, typename F12, typename F13, typename F14, typename F15, typename F16, typename F17, typename F18, typename F19, typename F20, typename F21, typename F22, typename F23, typename F24, typename F25, typename F26, typename F27, typename F28, typename F29, typename F30, typename F31> class Seq<F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28, F29, F30, F31> {
 private:
  char state_ = 0;
  struct State0 {
    State0(F0&& f0, F1&& f1) : f(std::forward<F0>(f0)), next(std::forward<F1>(f1)) {}
    State0(State0&& other) : f(std::move(other.f)), next(std::move(other.next)) {}
    State0(const State0& other) : f(other.f), next(other.next) {}
    ~State0() = delete;
    using F = F0;
    [[no_unique_address]] F0 f;
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F1>;
    [[no_unique_address]] Next next;
  };
  struct State1 {
    State1(F0&& f0, F1&& f1, F2&& f2) : next(std::forward<F2>(f2)) { new (&prior) State0(std::forward<F0>(f0), std::forward<F1>(f1)); }
    State1(State1&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State1(const State1& other) : prior(other.prior), next(other.next) {}
    ~State1() = delete;
    using F = typename State0::Next::Promise;
    union {
      [[no_unique_address]] State0 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F2>;
    [[no_unique_address]] Next next;
  };
  struct State2 {
    State2(F0&& f0, F1&& f1, F2&& f2, F3&& f3) : next(std::forward<F3>(f3)) { new (&prior) State1(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2)); }
    State2(State2&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State2(const State2& other) : prior(other.prior), next(other.next) {}
    ~State2() = delete;
    using F = typename State1::Next::Promise;
    union {
      [[no_unique_address]] State1 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F3>;
    [[no_unique_address]] Next next;
  };
  struct State3 {
    State3(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) : next(std::forward<F4>(f4)) { new (&prior) State2(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3)); }
    State3(State3&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State3(const State3& other) : prior(other.prior), next(other.next) {}
    ~State3() = delete;
    using F = typename State2::Next::Promise;
    union {
      [[no_unique_address]] State2 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F4>;
    [[no_unique_address]] Next next;
  };
  struct State4 {
    State4(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5) : next(std::forward<F5>(f5)) { new (&prior) State3(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4)); }
    State4(State4&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State4(const State4& other) : prior(other.prior), next(other.next) {}
    ~State4() = delete;
    using F = typename State3::Next::Promise;
    union {
      [[no_unique_address]] State3 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F5>;
    [[no_unique_address]] Next next;
  };
  struct State5 {
    State5(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6) : next(std::forward<F6>(f6)) { new (&prior) State4(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5)); }
    State5(State5&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State5(const State5& other) : prior(other.prior), next(other.next) {}
    ~State5() = delete;
    using F = typename State4::Next::Promise;
    union {
      [[no_unique_address]] State4 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F6>;
    [[no_unique_address]] Next next;
  };
  struct State6 {
    State6(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7) : next(std::forward<F7>(f7)) { new (&prior) State5(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6)); }
    State6(State6&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State6(const State6& other) : prior(other.prior), next(other.next) {}
    ~State6() = delete;
    using F = typename State5::Next::Promise;
    union {
      [[no_unique_address]] State5 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F7>;
    [[no_unique_address]] Next next;
  };
  struct State7 {
    State7(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8) : next(std::forward<F8>(f8)) { new (&prior) State6(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7)); }
    State7(State7&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State7(const State7& other) : prior(other.prior), next(other.next) {}
    ~State7() = delete;
    using F = typename State6::Next::Promise;
    union {
      [[no_unique_address]] State6 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F8>;
    [[no_unique_address]] Next next;
  };
  struct State8 {
    State8(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9) : next(std::forward<F9>(f9)) { new (&prior) State7(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8)); }
    State8(State8&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State8(const State8& other) : prior(other.prior), next(other.next) {}
    ~State8() = delete;
    using F = typename State7::Next::Promise;
    union {
      [[no_unique_address]] State7 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F9>;
    [[no_unique_address]] Next next;
  };
  struct State9 {
    State9(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10) : next(std::forward<F10>(f10)) { new (&prior) State8(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9)); }
    State9(State9&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State9(const State9& other) : prior(other.prior), next(other.next) {}
    ~State9() = delete;
    using F = typename State8::Next::Promise;
    union {
      [[no_unique_address]] State8 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F10>;
    [[no_unique_address]] Next next;
  };
  struct State10 {
    State10(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11) : next(std::forward<F11>(f11)) { new (&prior) State9(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10)); }
    State10(State10&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State10(const State10& other) : prior(other.prior), next(other.next) {}
    ~State10() = delete;
    using F = typename State9::Next::Promise;
    union {
      [[no_unique_address]] State9 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F11>;
    [[no_unique_address]] Next next;
  };
  struct State11 {
    State11(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12) : next(std::forward<F12>(f12)) { new (&prior) State10(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11)); }
    State11(State11&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State11(const State11& other) : prior(other.prior), next(other.next) {}
    ~State11() = delete;
    using F = typename State10::Next::Promise;
    union {
      [[no_unique_address]] State10 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F12>;
    [[no_unique_address]] Next next;
  };
  struct State12 {
    State12(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13) : next(std::forward<F13>(f13)) { new (&prior) State11(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12)); }
    State12(State12&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State12(const State12& other) : prior(other.prior), next(other.next) {}
    ~State12() = delete;
    using F = typename State11::Next::Promise;
    union {
      [[no_unique_address]] State11 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F13>;
    [[no_unique_address]] Next next;
  };
  struct State13 {
    State13(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14) : next(std::forward<F14>(f14)) { new (&prior) State12(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13)); }
    State13(State13&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State13(const State13& other) : prior(other.prior), next(other.next) {}
    ~State13() = delete;
    using F = typename State12::Next::Promise;
    union {
      [[no_unique_address]] State12 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F14>;
    [[no_unique_address]] Next next;
  };
  struct State14 {
    State14(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15) : next(std::forward<F15>(f15)) { new (&prior) State13(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14)); }
    State14(State14&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State14(const State14& other) : prior(other.prior), next(other.next) {}
    ~State14() = delete;
    using F = typename State13::Next::Promise;
    union {
      [[no_unique_address]] State13 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F15>;
    [[no_unique_address]] Next next;
  };
  struct State15 {
    State15(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16) : next(std::forward<F16>(f16)) { new (&prior) State14(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15)); }
    State15(State15&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State15(const State15& other) : prior(other.prior), next(other.next) {}
    ~State15() = delete;
    using F = typename State14::Next::Promise;
    union {
      [[no_unique_address]] State14 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F16>;
    [[no_unique_address]] Next next;
  };
  struct State16 {
    State16(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17) : next(std::forward<F17>(f17)) { new (&prior) State15(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16)); }
    State16(State16&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State16(const State16& other) : prior(other.prior), next(other.next) {}
    ~State16() = delete;
    using F = typename State15::Next::Promise;
    union {
      [[no_unique_address]] State15 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F17>;
    [[no_unique_address]] Next next;
  };
  struct State17 {
    State17(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18) : next(std::forward<F18>(f18)) { new (&prior) State16(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17)); }
    State17(State17&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State17(const State17& other) : prior(other.prior), next(other.next) {}
    ~State17() = delete;
    using F = typename State16::Next::Promise;
    union {
      [[no_unique_address]] State16 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F18>;
    [[no_unique_address]] Next next;
  };
  struct State18 {
    State18(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19) : next(std::forward<F19>(f19)) { new (&prior) State17(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18)); }
    State18(State18&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State18(const State18& other) : prior(other.prior), next(other.next) {}
    ~State18() = delete;
    using F = typename State17::Next::Promise;
    union {
      [[no_unique_address]] State17 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F19>;
    [[no_unique_address]] Next next;
  };
  struct State19 {
    State19(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20) : next(std::forward<F20>(f20)) { new (&prior) State18(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19)); }
    State19(State19&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State19(const State19& other) : prior(other.prior), next(other.next) {}
    ~State19() = delete;
    using F = typename State18::Next::Promise;
    union {
      [[no_unique_address]] State18 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F20>;
    [[no_unique_address]] Next next;
  };
  struct State20 {
    State20(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21) : next(std::forward<F21>(f21)) { new (&prior) State19(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20)); }
    State20(State20&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State20(const State20& other) : prior(other.prior), next(other.next) {}
    ~State20() = delete;
    using F = typename State19::Next::Promise;
    union {
      [[no_unique_address]] State19 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F21>;
    [[no_unique_address]] Next next;
  };
  struct State21 {
    State21(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22) : next(std::forward<F22>(f22)) { new (&prior) State20(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21)); }
    State21(State21&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State21(const State21& other) : prior(other.prior), next(other.next) {}
    ~State21() = delete;
    using F = typename State20::Next::Promise;
    union {
      [[no_unique_address]] State20 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F22>;
    [[no_unique_address]] Next next;
  };
  struct State22 {
    State22(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23) : next(std::forward<F23>(f23)) { new (&prior) State21(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22)); }
    State22(State22&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State22(const State22& other) : prior(other.prior), next(other.next) {}
    ~State22() = delete;
    using F = typename State21::Next::Promise;
    union {
      [[no_unique_address]] State21 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F23>;
    [[no_unique_address]] Next next;
  };
  struct State23 {
    State23(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24) : next(std::forward<F24>(f24)) { new (&prior) State22(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23)); }
    State23(State23&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State23(const State23& other) : prior(other.prior), next(other.next) {}
    ~State23() = delete;
    using F = typename State22::Next::Promise;
    union {
      [[no_unique_address]] State22 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F24>;
    [[no_unique_address]] Next next;
  };
  struct State24 {
    State24(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25) : next(std::forward<F25>(f25)) { new (&prior) State23(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24)); }
    State24(State24&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State24(const State24& other) : prior(other.prior), next(other.next) {}
    ~State24() = delete;
    using F = typename State23::Next::Promise;
    union {
      [[no_unique_address]] State23 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F25>;
    [[no_unique_address]] Next next;
  };
  struct State25 {
    State25(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26) : next(std::forward<F26>(f26)) { new (&prior) State24(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25)); }
    State25(State25&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State25(const State25& other) : prior(other.prior), next(other.next) {}
    ~State25() = delete;
    using F = typename State24::Next::Promise;
    union {
      [[no_unique_address]] State24 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F26>;
    [[no_unique_address]] Next next;
  };
  struct State26 {
    State26(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27) : next(std::forward<F27>(f27)) { new (&prior) State25(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26)); }
    State26(State26&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State26(const State26& other) : prior(other.prior), next(other.next) {}
    ~State26() = delete;
    using F = typename State25::Next::Promise;
    union {
      [[no_unique_address]] State25 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F27>;
    [[no_unique_address]] Next next;
  };
  struct State27 {
    State27(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28) : next(std::forward<F28>(f28)) { new (&prior) State26(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27)); }
    State27(State27&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State27(const State27& other) : prior(other.prior), next(other.next) {}
    ~State27() = delete;
    using F = typename State26::Next::Promise;
    union {
      [[no_unique_address]] State26 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F28>;
    [[no_unique_address]] Next next;
  };
  struct State28 {
    State28(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28, F29&& f29) : next(std::forward<F29>(f29)) { new (&prior) State27(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27), std::forward<F28>(f28)); }
    State28(State28&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State28(const State28& other) : prior(other.prior), next(other.next) {}
    ~State28() = delete;
    using F = typename State27::Next::Promise;
    union {
      [[no_unique_address]] State27 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F29>;
    [[no_unique_address]] Next next;
  };
  struct State29 {
    State29(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28, F29&& f29, F30&& f30) : next(std::forward<F30>(f30)) { new (&prior) State28(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27), std::forward<F28>(f28), std::forward<F29>(f29)); }
    State29(State29&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State29(const State29& other) : prior(other.prior), next(other.next) {}
    ~State29() = delete;
    using F = typename State28::Next::Promise;
    union {
      [[no_unique_address]] State28 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F30>;
    [[no_unique_address]] Next next;
  };
  struct State30 {
    State30(F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6, F7&& f7, F8&& f8, F9&& f9, F10&& f10, F11&& f11, F12&& f12, F13&& f13, F14&& f14, F15&& f15, F16&& f16, F17&& f17, F18&& f18, F19&& f19, F20&& f20, F21&& f21, F22&& f22, F23&& f23, F24&& f24, F25&& f25, F26&& f26, F27&& f27, F28&& f28, F29&& f29, F30&& f30, F31&& f31) : next(std::forward<F31>(f31)) { new (&prior) State29(std::forward<F0>(f0), std::forward<F1>(f1), std::forward<F2>(f2), std::forward<F3>(f3), std::forward<F4>(f4), std::forward<F5>(f5), std::forward<F6>(f6), std::forward<F7>(f7), std::forward<F8>(f8), std::forward<F9>(f9), std::forward<F10>(f10), std::forward<F11>(f11), std::forward<F12>(f12), std::forward<F13>(f13), std::forward<F14>(f14), std::forward<F15>(f15), std::forward<F16>(f16), std::forward<F17>(f17), std::forward<F18>(f18), std::forward<F19>(f19), std::forward<F20>(f20), std::forward<F21>(f21), std::forward<F22>(f22), std::forward<F23>(f23), std::forward<F24>(f24), std::forward<F25>(f25), std::forward<F26>(f26), std::forward<F27>(f27), std::forward<F28>(f28), std::forward<F29>(f29), std::forward<F30>(f30)); }
    State30(State30&& other) : prior(std::move(other.prior)), next(std::move(other.next)) {}
    State30(const State30& other) : prior(other.prior), next(other.next) {}
    ~State30() = delete;
    using F = typename State29::Next::Promise;
    union {
      [[no_unique_address]] State29 prior;
      [[no_unique_address]] F f;
    };
    using FResult = absl::remove_reference_t<decltype(*f().get_ready())>;
    using Next = adaptor_detail::Factory<FResult, F31>;
    [[no_unique_address]] Next next;
  };
  using FLast = typename State30::Next::Promise;
  union {
    [[no_unique_address]] State30 prior_;
    [[no_unique_address]] FLast f_;
  };
 public:
  Seq(F0 f0, F1 f1, F2 f2, F3 f3, F4 f4, F5 f5, F6 f6, F7 f7, F8 f8, F9 f9, F10 f10, F11 f11, F12 f12, F13 f13, F14 f14, F15 f15, F16 f16, F17 f17, F18 f18, F19 f19, F20 f20, F21 f21, F22 f22, F23 f23, F24 f24, F25 f25, F26 f26, F27 f27, F28 f28, F29 f29, F30 f30, F31 f31) : prior_(std::move(f0), std::move(f1), std::move(f2), std::move(f3), std::move(f4), std::move(f5), std::move(f6), std::move(f7), std::move(f8), std::move(f9), std::move(f10), std::move(f11), std::move(f12), std::move(f13), std::move(f14), std::move(f15), std::move(f16), std::move(f17), std::move(f18), std::move(f19), std::move(f20), std::move(f21), std::move(f22), std::move(f23), std::move(f24), std::move(f25), std::move(f26), std::move(f27), std::move(f28), std::move(f29), std::move(f30), std::move(f31)) {}
  Seq& operator=(const Seq&) = delete;
  Seq(const Seq& other) {
    assert(other.state_ == 0);
    new (&prior_) State30(other.prior_);
  }
  Seq(Seq&& other) {
    assert(other.state_ == 0);
    new (&prior_) State30(std::move(other.prior_));
  }
  ~Seq() {
    switch (state_) {
     case 0:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin0;
     case 1:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin1;
     case 2:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin2;
     case 3:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin3;
     case 4:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin4;
     case 5:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin5;
     case 6:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin6;
     case 7:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin7;
     case 8:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin8;
     case 9:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin9;
     case 10:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin10;
     case 11:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin11;
     case 12:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin12;
     case 13:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin13;
     case 14:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin14;
     case 15:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin15;
     case 16:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin16;
     case 17:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin17;
     case 18:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin18;
     case 19:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin19;
     case 20:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin20;
     case 21:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin21;
     case 22:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin22;
     case 23:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      goto fin23;
     case 24:
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      goto fin24;
     case 25:
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      goto fin25;
     case 26:
      Destruct(&prior_.prior.prior.prior.prior.f);
      goto fin26;
     case 27:
      Destruct(&prior_.prior.prior.prior.f);
      goto fin27;
     case 28:
      Destruct(&prior_.prior.prior.f);
      goto fin28;
     case 29:
      Destruct(&prior_.prior.f);
      goto fin29;
     case 30:
      Destruct(&prior_.f);
      goto fin30;
     case 31:
      Destruct(&f_);
      return;
    }
  fin0:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin1:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin2:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin3:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin4:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin5:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin6:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin7:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin8:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin9:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin10:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin11:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin12:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin13:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin14:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin15:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin16:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin17:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin18:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin19:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin20:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin21:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin22:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
  fin23:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
  fin24:
    Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
  fin25:
    Destruct(&prior_.prior.prior.prior.prior.prior.next);
  fin26:
    Destruct(&prior_.prior.prior.prior.prior.next);
  fin27:
    Destruct(&prior_.prior.prior.prior.next);
  fin28:
    Destruct(&prior_.prior.prior.next);
  fin29:
    Destruct(&prior_.prior.next);
  fin30:
    Destruct(&prior_.next);
  }
  decltype(std::declval<typename State30::Next::Promise>()()) operator()() {
    switch (state_) {
     case 0: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State0::Next::Promise(std::move(n));
      state_ = 1;
     }
     case 1: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State1::Next::Promise(std::move(n));
      state_ = 2;
     }
     case 2: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State2::Next::Promise(std::move(n));
      state_ = 3;
     }
     case 3: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State3::Next::Promise(std::move(n));
      state_ = 4;
     }
     case 4: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State4::Next::Promise(std::move(n));
      state_ = 5;
     }
     case 5: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State5::Next::Promise(std::move(n));
      state_ = 6;
     }
     case 6: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State6::Next::Promise(std::move(n));
      state_ = 7;
     }
     case 7: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State7::Next::Promise(std::move(n));
      state_ = 8;
     }
     case 8: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State8::Next::Promise(std::move(n));
      state_ = 9;
     }
     case 9: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State9::Next::Promise(std::move(n));
      state_ = 10;
     }
     case 10: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State10::Next::Promise(std::move(n));
      state_ = 11;
     }
     case 11: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State11::Next::Promise(std::move(n));
      state_ = 12;
     }
     case 12: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State12::Next::Promise(std::move(n));
      state_ = 13;
     }
     case 13: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State13::Next::Promise(std::move(n));
      state_ = 14;
     }
     case 14: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State14::Next::Promise(std::move(n));
      state_ = 15;
     }
     case 15: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State15::Next::Promise(std::move(n));
      state_ = 16;
     }
     case 16: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State16::Next::Promise(std::move(n));
      state_ = 17;
     }
     case 17: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State17::Next::Promise(std::move(n));
      state_ = 18;
     }
     case 18: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State18::Next::Promise(std::move(n));
      state_ = 19;
     }
     case 19: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State19::Next::Promise(std::move(n));
      state_ = 20;
     }
     case 20: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State20::Next::Promise(std::move(n));
      state_ = 21;
     }
     case 21: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f) typename State21::Next::Promise(std::move(n));
      state_ = 22;
     }
     case 22: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.prior.f) typename State22::Next::Promise(std::move(n));
      state_ = 23;
     }
     case 23: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.prior.f) typename State23::Next::Promise(std::move(n));
      state_ = 24;
     }
     case 24: {
      auto r = prior_.prior.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.prior.f) typename State24::Next::Promise(std::move(n));
      state_ = 25;
     }
     case 25: {
      auto r = prior_.prior.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.prior.f) typename State25::Next::Promise(std::move(n));
      state_ = 26;
     }
     case 26: {
      auto r = prior_.prior.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.prior.next);
      new (&prior_.prior.prior.prior.f) typename State26::Next::Promise(std::move(n));
      state_ = 27;
     }
     case 27: {
      auto r = prior_.prior.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.prior.f);
      auto n = prior_.prior.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.prior.next);
      new (&prior_.prior.prior.f) typename State27::Next::Promise(std::move(n));
      state_ = 28;
     }
     case 28: {
      auto r = prior_.prior.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.prior.f);
      auto n = prior_.prior.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.prior.next);
      new (&prior_.prior.f) typename State28::Next::Promise(std::move(n));
      state_ = 29;
     }
     case 29: {
      auto r = prior_.prior.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.prior.f);
      auto n = prior_.prior.next.Once(std::move(*p));
      Destruct(&prior_.prior.next);
      new (&prior_.f) typename State29::Next::Promise(std::move(n));
      state_ = 30;
     }
     case 30: {
      auto r = prior_.f();
      auto* p = r.get_ready();
      if (p == nullptr) break;
      Destruct(&prior_.f);
      auto n = prior_.next.Once(std::move(*p));
      Destruct(&prior_.next);
      new (&f_) typename State30::Next::Promise(std::move(n));
      state_ = 31;
     }
     case 31:
      return f_();
    }
    return kPending;
  }
};
