/*
 *
 * Copyright 2017 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Code generated by tools/codegen/core/gen_closure_ref.py

#ifndef GRPC_CORE_LIB_SUPPORT_CLOSURE_REF_H
#define GRPC_CORE_LIB_SUPPORT_CLOSURE_REF_H

#include <stdio.h>
#include <stdlib.h>
#include <utility>

namespace grpc_core {

namespace closure_impl {
// forward-declaration
template <class Scheduler>
class MakesClosuresForScheduler;
}  // namespace closure_impl

// Value type reference to some closure
// Template arguments list argument types to the closure
// Closures have an implicit scheduling policy bound when they are created
template <typename... Args>
class ClosureRef {
 public:
  struct VTable {
    void (*schedule)(void* env, Args&&... args);
    void (*run)(void* env, Args&&... args);
  };

  ClosureRef() : vtable_(&null_vtable_), env_(nullptr) {}

  // Run this closure, in-place if possible
  // Requires that no grpc-locks be held in the current callstack
  void UnsafeRun(Args&&... args) {
    vtable_->run(env_, std::forward<Args>(args)...);
  }

  // Schedule this closure for execution in a safe environment
  void Schedule(Args&&... args) {
    vtable_->schedule(env_, std::forward<Args>(args)...);
  }

 private:
  template <class Scheduler>
  friend class closure_impl::MakesClosuresForScheduler;

  ClosureRef(const VTable* vtable, void* env) : vtable_(vtable), env_(env) {}

  const VTable* vtable_;
  void* env_;

  static void null_exec(void* env, Args&&... args) { abort(); }

  static const VTable null_vtable_;
};

template <typename... Args>
const typename ClosureRef<Args...>::VTable ClosureRef<Args...>::null_vtable_ = {
    ClosureRef<Args...>::null_exec, ClosureRef<Args...>::null_exec,
};

//
// MakeClosure implementation details...
//

namespace closure_impl {

template <class Scheduler, class Env, void (*F)()>
class FnClosure0 {
 public:
  static const typename ClosureRef<>::VTable vtable;

 private:
  static void Schedule(void* env) {
    Scheduler::Schedule([](void*) { F(); }, static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env) {
    Scheduler::UnsafeRun([](void*) { F(); }, static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, void (*F)()>
const typename ClosureRef<>::VTable FnClosure0<Scheduler, Env, F>::vtable = {
    Schedule, UnsafeRun};

template <class Scheduler, class C, void (C::*F)()>
class MemClosure0 {
 public:
  static const typename ClosureRef<>::VTable vtable;

 private:
  static void Schedule(void* env) {
    Scheduler::Schedule([](void* env) { (static_cast<C*>(env)->*F)(); },
                        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env) {
    Scheduler::UnsafeRun([](void* env) { (static_cast<C*>(env)->*F)(); },
                         static_cast<C*>(env));
  }
};

template <class Scheduler, class C, void (C::*F)()>
const typename ClosureRef<>::VTable MemClosure0<Scheduler, C, F>::vtable = {
    Schedule, UnsafeRun};

template <class Scheduler, class Env, typename T1, void (*F)(T1)>
class FnClosure1 {
 public:
  static const typename ClosureRef<T1>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1) {
    Scheduler::Schedule([t1](void*) { F(t1); }, static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1) {
    Scheduler::UnsafeRun([t1](void*) { F(t1); }, static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, void (*F)(T1)>
const typename ClosureRef<T1>::VTable
    FnClosure1<Scheduler, Env, T1, F>::vtable = {Schedule, UnsafeRun};

template <class Scheduler, class C, typename T1, void (C::*F)(T1)>
class MemClosure1 {
 public:
  static const typename ClosureRef<T1>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1) {
    Scheduler::Schedule([t1](void* env) { (static_cast<C*>(env)->*F)(t1); },
                        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1) {
    Scheduler::UnsafeRun([t1](void* env) { (static_cast<C*>(env)->*F)(t1); },
                         static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, void (C::*F)(T1)>
const typename ClosureRef<T1>::VTable MemClosure1<Scheduler, C, T1, F>::vtable =
    {Schedule, UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2,
          void (*F)(T1, T2)>
class FnClosure2 {
 public:
  static const typename ClosureRef<T1, T2>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2) {
    Scheduler::Schedule([t1, t2](void*) { F(t1, t2); }, static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2) {
    Scheduler::UnsafeRun([t1, t2](void*) { F(t1, t2); },
                         static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2,
          void (*F)(T1, T2)>
const typename ClosureRef<T1, T2>::VTable
    FnClosure2<Scheduler, Env, T1, T2, F>::vtable = {Schedule, UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2,
          void (C::*F)(T1, T2)>
class MemClosure2 {
 public:
  static const typename ClosureRef<T1, T2>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2) {
    Scheduler::Schedule(
        [t1, t2](void* env) { (static_cast<C*>(env)->*F)(t1, t2); },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2) {
    Scheduler::UnsafeRun(
        [t1, t2](void* env) { (static_cast<C*>(env)->*F)(t1, t2); },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2,
          void (C::*F)(T1, T2)>
const typename ClosureRef<T1, T2>::VTable
    MemClosure2<Scheduler, C, T1, T2, F>::vtable = {Schedule, UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          void (*F)(T1, T2, T3)>
class FnClosure3 {
 public:
  static const typename ClosureRef<T1, T2, T3>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3) {
    Scheduler::Schedule([t1, t2, t3](void*) { F(t1, t2, t3); },
                        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3) {
    Scheduler::UnsafeRun([t1, t2, t3](void*) { F(t1, t2, t3); },
                         static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          void (*F)(T1, T2, T3)>
const typename ClosureRef<T1, T2, T3>::VTable
    FnClosure3<Scheduler, Env, T1, T2, T3, F>::vtable = {Schedule, UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          void (C::*F)(T1, T2, T3)>
class MemClosure3 {
 public:
  static const typename ClosureRef<T1, T2, T3>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3) {
    Scheduler::Schedule(
        [t1, t2, t3](void* env) { (static_cast<C*>(env)->*F)(t1, t2, t3); },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3) {
    Scheduler::UnsafeRun(
        [t1, t2, t3](void* env) { (static_cast<C*>(env)->*F)(t1, t2, t3); },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          void (C::*F)(T1, T2, T3)>
const typename ClosureRef<T1, T2, T3>::VTable
    MemClosure3<Scheduler, C, T1, T2, T3, F>::vtable = {Schedule, UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, void (*F)(T1, T2, T3, T4)>
class FnClosure4 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4) {
    Scheduler::Schedule([t1, t2, t3, t4](void*) { F(t1, t2, t3, t4); },
                        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4) {
    Scheduler::UnsafeRun([t1, t2, t3, t4](void*) { F(t1, t2, t3, t4); },
                         static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, void (*F)(T1, T2, T3, T4)>
const typename ClosureRef<T1, T2, T3, T4>::VTable
    FnClosure4<Scheduler, Env, T1, T2, T3, T4, F>::vtable = {Schedule,
                                                             UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, void (C::*F)(T1, T2, T3, T4)>
class MemClosure4 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4) {
    Scheduler::Schedule(
        [t1, t2, t3, t4](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4);
        },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4);
        },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, void (C::*F)(T1, T2, T3, T4)>
const typename ClosureRef<T1, T2, T3, T4>::VTable
    MemClosure4<Scheduler, C, T1, T2, T3, T4, F>::vtable = {Schedule,
                                                            UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, void (*F)(T1, T2, T3, T4, T5)>
class FnClosure5 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5) {
    Scheduler::Schedule([t1, t2, t3, t4, t5](void*) { F(t1, t2, t3, t4, t5); },
                        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4,
                        T5&& t5) {
    Scheduler::UnsafeRun([t1, t2, t3, t4, t5](void*) { F(t1, t2, t3, t4, t5); },
                         static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, void (*F)(T1, T2, T3, T4, T5)>
const typename ClosureRef<T1, T2, T3, T4, T5>::VTable
    FnClosure5<Scheduler, Env, T1, T2, T3, T4, T5, F>::vtable = {Schedule,
                                                                 UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, void (C::*F)(T1, T2, T3, T4, T5)>
class MemClosure5 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5);
        },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4,
                        T5&& t5) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5);
        },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, void (C::*F)(T1, T2, T3, T4, T5)>
const typename ClosureRef<T1, T2, T3, T4, T5>::VTable
    MemClosure5<Scheduler, C, T1, T2, T3, T4, T5, F>::vtable = {Schedule,
                                                                UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6,
          void (*F)(T1, T2, T3, T4, T5, T6)>
class FnClosure6 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5, t6](void*) { F(t1, t2, t3, t4, t5, t6); },
        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5, t6](void*) { F(t1, t2, t3, t4, t5, t6); },
        static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6,
          void (*F)(T1, T2, T3, T4, T5, T6)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6>::VTable
    FnClosure6<Scheduler, Env, T1, T2, T3, T4, T5, T6, F>::vtable = {Schedule,
                                                                     UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6,
          void (C::*F)(T1, T2, T3, T4, T5, T6)>
class MemClosure6 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5, t6](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6);
        },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5, t6](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6);
        },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6,
          void (C::*F)(T1, T2, T3, T4, T5, T6)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6>::VTable
    MemClosure6<Scheduler, C, T1, T2, T3, T4, T5, T6, F>::vtable = {Schedule,
                                                                    UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7,
          void (*F)(T1, T2, T3, T4, T5, T6, T7)>
class FnClosure7 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6, T7&& t7) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5, t6, t7](void*) { F(t1, t2, t3, t4, t5, t6, t7); },
        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6, T7&& t7) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5, t6, t7](void*) { F(t1, t2, t3, t4, t5, t6, t7); },
        static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7,
          void (*F)(T1, T2, T3, T4, T5, T6, T7)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7>::VTable
    FnClosure7<Scheduler, Env, T1, T2, T3, T4, T5, T6, T7, F>::vtable = {
        Schedule, UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7,
          void (C::*F)(T1, T2, T3, T4, T5, T6, T7)>
class MemClosure7 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7>::VTable vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6, T7&& t7) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5, t6, t7](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6, t7);
        },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6, T7&& t7) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5, t6, t7](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6, t7);
        },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7,
          void (C::*F)(T1, T2, T3, T4, T5, T6, T7)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7>::VTable
    MemClosure7<Scheduler, C, T1, T2, T3, T4, T5, T6, T7, F>::vtable = {
        Schedule, UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          void (*F)(T1, T2, T3, T4, T5, T6, T7, T8)>
class FnClosure8 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8>::VTable
      vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6, T7&& t7, T8&& t8) {
    Scheduler::Schedule([t1, t2, t3, t4, t5, t6, t7,
                         t8](void*) { F(t1, t2, t3, t4, t5, t6, t7, t8); },
                        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6, T7&& t7, T8&& t8) {
    Scheduler::UnsafeRun([t1, t2, t3, t4, t5, t6, t7,
                          t8](void*) { F(t1, t2, t3, t4, t5, t6, t7, t8); },
                         static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          void (*F)(T1, T2, T3, T4, T5, T6, T7, T8)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8>::VTable
    FnClosure8<Scheduler, Env, T1, T2, T3, T4, T5, T6, T7, T8, F>::vtable = {
        Schedule, UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          void (C::*F)(T1, T2, T3, T4, T5, T6, T7, T8)>
class MemClosure8 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8>::VTable
      vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6, T7&& t7, T8&& t8) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5, t6, t7, t8](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6, t7, t8);
        },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6, T7&& t7, T8&& t8) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5, t6, t7, t8](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6, t7, t8);
        },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          void (C::*F)(T1, T2, T3, T4, T5, T6, T7, T8)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8>::VTable
    MemClosure8<Scheduler, C, T1, T2, T3, T4, T5, T6, T7, T8, F>::vtable = {
        Schedule, UnsafeRun};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          typename T9, void (*F)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
class FnClosure9 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9>::VTable
      vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6, T7&& t7, T8&& t8, T9&& t9) {
    Scheduler::Schedule([t1, t2, t3, t4, t5, t6, t7, t8,
                         t9](void*) { F(t1, t2, t3, t4, t5, t6, t7, t8, t9); },
                        static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6, T7&& t7, T8&& t8, T9&& t9) {
    Scheduler::UnsafeRun([t1, t2, t3, t4, t5, t6, t7, t8,
                          t9](void*) { F(t1, t2, t3, t4, t5, t6, t7, t8, t9); },
                         static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          typename T9, void (*F)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9>::VTable
    FnClosure9<Scheduler, Env, T1, T2, T3, T4, T5, T6, T7, T8, T9, F>::vtable =
        {Schedule, UnsafeRun};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          typename T9, void (C::*F)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
class MemClosure9 {
 public:
  static const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9>::VTable
      vtable;

 private:
  static void Schedule(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                       T6&& t6, T7&& t7, T8&& t8, T9&& t9) {
    Scheduler::Schedule(
        [t1, t2, t3, t4, t5, t6, t7, t8, t9](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6, t7, t8, t9);
        },
        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env, T1&& t1, T2&& t2, T3&& t3, T4&& t4, T5&& t5,
                        T6&& t6, T7&& t7, T8&& t8, T9&& t9) {
    Scheduler::UnsafeRun(
        [t1, t2, t3, t4, t5, t6, t7, t8, t9](void* env) {
          (static_cast<C*>(env)->*F)(t1, t2, t3, t4, t5, t6, t7, t8, t9);
        },
        static_cast<C*>(env));
  }
};

template <class Scheduler, class C, typename T1, typename T2, typename T3,
          typename T4, typename T5, typename T6, typename T7, typename T8,
          typename T9, void (C::*F)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
const typename ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9>::VTable
    MemClosure9<Scheduler, C, T1, T2, T3, T4, T5, T6, T7, T8, T9, F>::vtable = {
        Schedule, UnsafeRun};

template <class Scheduler>
class MakesClosuresForScheduler {
 public:
  /// Construct a ClosureRef that calls a free function with 0 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <void (*F)(), typename Env = std::nullptr_t>
  ClosureRef<> MakeClosure(Env* env = nullptr) {
    return ClosureRef<>(&closure_impl::FnClosure0<Scheduler, Env, F>::vtable,
                        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 0
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, void (C::*F)()>
  ClosureRef<> MakeClosure(C* p) {
    return ClosureRef<>(&closure_impl::MemClosure0<Scheduler, C, F>::vtable, p);
  }

  /// Construct a ClosureRef that calls a free function with 1 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, void (*F)(T1), typename Env = std::nullptr_t>
  ClosureRef<T1> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1>(
        &closure_impl::FnClosure1<Scheduler, Env, T1, F>::vtable, env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 1
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, void (C::*F)(T1)>
  ClosureRef<T1> MakeClosure(C* p) {
    return ClosureRef<T1>(
        &closure_impl::MemClosure1<Scheduler, C, T1, F>::vtable, p);
  }

  /// Construct a ClosureRef that calls a free function with 2 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, void (*F)(T1, T2),
            typename Env = std::nullptr_t>
  ClosureRef<T1, T2> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2>(
        &closure_impl::FnClosure2<Scheduler, Env, T1, T2, F>::vtable, env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 2
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, void (C::*F)(T1, T2)>
  ClosureRef<T1, T2> MakeClosure(C* p) {
    return ClosureRef<T1, T2>(
        &closure_impl::MemClosure2<Scheduler, C, T1, T2, F>::vtable, p);
  }

  /// Construct a ClosureRef that calls a free function with 3 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, void (*F)(T1, T2, T3),
            typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2, T3>(
        &closure_impl::FnClosure3<Scheduler, Env, T1, T2, T3, F>::vtable, env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 3
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3,
            void (C::*F)(T1, T2, T3)>
  ClosureRef<T1, T2, T3> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3>(
        &closure_impl::MemClosure3<Scheduler, C, T1, T2, T3, F>::vtable, p);
  }

  /// Construct a ClosureRef that calls a free function with 4 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, typename T4,
            void (*F)(T1, T2, T3, T4), typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3, T4> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2, T3, T4>(
        &closure_impl::FnClosure4<Scheduler, Env, T1, T2, T3, T4, F>::vtable,
        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 4
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3, typename T4,
            void (C::*F)(T1, T2, T3, T4)>
  ClosureRef<T1, T2, T3, T4> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3, T4>(
        &closure_impl::MemClosure4<Scheduler, C, T1, T2, T3, T4, F>::vtable, p);
  }

  /// Construct a ClosureRef that calls a free function with 5 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            void (*F)(T1, T2, T3, T4, T5), typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3, T4, T5> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2, T3, T4, T5>(
        &closure_impl::FnClosure5<Scheduler, Env, T1, T2, T3, T4, T5,
                                  F>::vtable,
        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 5
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3, typename T4,
            typename T5, void (C::*F)(T1, T2, T3, T4, T5)>
  ClosureRef<T1, T2, T3, T4, T5> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3, T4, T5>(
        &closure_impl::MemClosure5<Scheduler, C, T1, T2, T3, T4, T5, F>::vtable,
        p);
  }

  /// Construct a ClosureRef that calls a free function with 6 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            typename T6, void (*F)(T1, T2, T3, T4, T5, T6),
            typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3, T4, T5, T6> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2, T3, T4, T5, T6>(
        &closure_impl::FnClosure6<Scheduler, Env, T1, T2, T3, T4, T5, T6,
                                  F>::vtable,
        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 6
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3, typename T4,
            typename T5, typename T6, void (C::*F)(T1, T2, T3, T4, T5, T6)>
  ClosureRef<T1, T2, T3, T4, T5, T6> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3, T4, T5, T6>(
        &closure_impl::MemClosure6<Scheduler, C, T1, T2, T3, T4, T5, T6,
                                   F>::vtable,
        p);
  }

  /// Construct a ClosureRef that calls a free function with 7 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            typename T6, typename T7, void (*F)(T1, T2, T3, T4, T5, T6, T7),
            typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3, T4, T5, T6, T7> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2, T3, T4, T5, T6, T7>(
        &closure_impl::FnClosure7<Scheduler, Env, T1, T2, T3, T4, T5, T6, T7,
                                  F>::vtable,
        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 7
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3, typename T4,
            typename T5, typename T6, typename T7,
            void (C::*F)(T1, T2, T3, T4, T5, T6, T7)>
  ClosureRef<T1, T2, T3, T4, T5, T6, T7> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3, T4, T5, T6, T7>(
        &closure_impl::MemClosure7<Scheduler, C, T1, T2, T3, T4, T5, T6, T7,
                                   F>::vtable,
        p);
  }

  /// Construct a ClosureRef that calls a free function with 8 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            typename T6, typename T7, typename T8,
            void (*F)(T1, T2, T3, T4, T5, T6, T7, T8),
            typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8> MakeClosure(Env* env = nullptr) {
    return ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8>(
        &closure_impl::FnClosure8<Scheduler, Env, T1, T2, T3, T4, T5, T6, T7,
                                  T8, F>::vtable,
        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 8
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3, typename T4,
            typename T5, typename T6, typename T7, typename T8,
            void (C::*F)(T1, T2, T3, T4, T5, T6, T7, T8)>
  ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8>(
        &closure_impl::MemClosure8<Scheduler, C, T1, T2, T3, T4, T5, T6, T7, T8,
                                   F>::vtable,
        p);
  }

  /// Construct a ClosureRef that calls a free function with 9 arguments. The
  /// optional env parameter defines an environment, and is required for
  /// schedulers that retrieve data from some environment (e.g. Combiner)
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            typename T6, typename T7, typename T8, typename T9,
            void (*F)(T1, T2, T3, T4, T5, T6, T7, T8, T9),
            typename Env = std::nullptr_t>
  ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9> MakeClosure(
      Env* env = nullptr) {
    return ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
        &closure_impl::FnClosure9<Scheduler, Env, T1, T2, T3, T4, T5, T6, T7,
                                  T8, T9, F>::vtable,
        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with 9
  /// arguments. The closure environment is assumed to be the instance pointer
  /// to C, and is required
  template <class C, typename T1, typename T2, typename T3, typename T4,
            typename T5, typename T6, typename T7, typename T8, typename T9,
            void (C::*F)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
  ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9> MakeClosure(C* p) {
    return ClosureRef<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
        &closure_impl::MemClosure9<Scheduler, C, T1, T2, T3, T4, T5, T6, T7, T8,
                                   T9, F>::vtable,
        p);
  }
};

}  // namespace closure_impl

//
// SCHEDULERS
//

class AcquiresNoLocks
    : public closure_impl::MakesClosuresForScheduler<AcquiresNoLocks> {
 public:
  template <class T, class F>
  static void Schedule(F&& f, T* env) {
    f(env);
  }
  template <class T, class F>
  static void UnsafeRun(F&& f, T* env) {
    f(env);
  }
};

// TODO(ctiller): move this into it's final place
#if 0
template <class F>
void QueueOnExecCtx(F&& f);

class RunInCurrentThread : public closure_impl::MakesClosuresForScheduler<RunInCurrentThread> {
 public:
  template <class T, class F>
  static void Schedule(F&& f, T* env) {
    QueueOnExecCtx([f, env]() { f(env); });
  }
  template <class T, class F>
  static void UnsafeRun(F&& f, T* env) {
    f(env);
  }
};

class RunInCombiner : public closure_impl::MakesClosuresForScheduler<RunInCombiner> {
 public:
  template <class T, class F>
  static void Schedule(F&& f, T* env) {
    env->combiner()->Schedule([f, env]() { f(env); });
  }
  template <class T, class F>
  static void UnsafeRun(F&& f, T* env) {
    env->combiner()->UnsafeRun([f, env]() { f(env); });
  }
};

// Dummy combiner lock impl

class Combiner {
 public:
  template <class F>
  void Schedule(F&& f);
  template <class F>
  void UnsafeRun(F&& f);
};

//
// TEST CODE
//

void PrintLine();
void PrintInt(int);

class Foo {
 public:
  void Callback();

  Combiner* combiner() { return &combiner_; }

 private:
  Combiner combiner_;
};

ClosureRef<> Hidden();

void test() {
  // simple closures around functions, member functions
  ClosureRef<> print_line = AcquiresNoLocks::MakeClosure<PrintLine>();
  ClosureRef<int> print_int = AcquiresNoLocks::MakeClosure<int, PrintInt>();
  Foo foo;
  ClosureRef<> foo_cb = AcquiresNoLocks::MakeClosure<Foo, &Foo::Callback>(&foo);

  print_line.UnsafeRun();
  print_int.UnsafeRun(42);
  foo_cb.UnsafeRun();

  // exec context test
  ClosureRef<> foo_cb_in_exec_ctx =
      RunInCurrentThread::MakeClosure<Foo, &Foo::Callback>(&foo);
  foo_cb_in_exec_ctx.Schedule();

  // combiner lock test - picks up combiner from Foo
  ClosureRef<> foo_cb_in_combiner =
      RunInCombiner::MakeClosure<Foo, &Foo::Callback>(&foo);
  foo_cb_in_combiner.Schedule();
  // can pass in a raw function too, but need to provide an environment
  // in this case something that provides a combiner() method
  ClosureRef<> print_line_in_combiner =
      RunInCombiner::MakeClosure<PrintLine>(&foo);
  print_line_in_combiner.Schedule();

  Hidden().UnsafeRun();

  // empty closure test
  ClosureRef<> empty;
  empty.UnsafeRun();
}
#endif

}  // namespace grpc_core

#endif /* GRPC_CORE_LIB_SUPPORT_CLOSURE_REF_H */
