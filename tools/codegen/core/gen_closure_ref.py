#!/usr/bin/env python2.7
# Copyright 2017 gRPC authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate src/core/lib/support/closure_ref.h"""

_TEMPLATE = """/*
 *
 * Copyright 2017 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Code generated by tools/codegen/core/gen_closure_ref.py

#ifndef GRPC_CORE_LIB_SUPPORT_CLOSURE_REF_H
#define GRPC_CORE_LIB_SUPPORT_CLOSURE_REF_H

<% GENERATE_ARGS = 10 %>

#include <stdio.h>
#include <stdlib.h>
#include <utility>

namespace grpc_core {

namespace closure_impl {
// forward-declaration
template <class Scheduler>
class MakesClosuresForScheduler;
} // namespace closure_impl

// Value type reference to some closure
// Template arguments list argument types to the closure
// Closures have an implicit scheduling policy bound when they are created
template <typename... Args>
class ClosureRef {
 public:
  struct VTable {
    void (*schedule)(void* env, Args&&... args);
    void (*run)(void* env, Args&&... args);
  };

  ClosureRef() : vtable_(&null_vtable_), env_(nullptr) {}

  // Run this closure, in-place if possible
  // Requires that no grpc-locks be held in the current callstack
  void UnsafeRun(Args&&... args) { vtable_->run(env_, std::forward<Args>(args)...); }

  // Schedule this closure for execution in a safe environment
  void Schedule(Args&&... args) {
    vtable_->schedule(env_, std::forward<Args>(args)...);
  }

 private:
  template <class Scheduler>
  friend class closure_impl::MakesClosuresForScheduler;

  ClosureRef(const VTable* vtable, void* env) : vtable_(vtable), env_(env) {}

  const VTable* vtable_;
  void* env_;

  static void null_exec(void* env, Args&&... args) { abort(); }

  static const VTable null_vtable_;
};

template <typename... Args>
const typename ClosureRef<Args...>::VTable ClosureRef<Args...>::null_vtable_ = {
    ClosureRef<Args...>::null_exec, ClosureRef<Args...>::null_exec,
};

//
// MakeClosure implementation details...
//

namespace closure_impl {

% for arg_count in range(0, GENERATE_ARGS):
<%
  # _tc means 'trailing comma'
  # _pc means 'prefixed comma'
  typename_T_list_tc = ''.join('typename T%d, ' % (n+1) for n in range(0,arg_count))
  T_list = ', '.join('T%d' % (n+1) for n in range(0,arg_count))
  T_list_tc = ''.join('T%d, ' % (n+1) for n in range(0,arg_count))
  t_list = ', '.join('t%d' % (n+1) for n in range(0,arg_count))
  fun_args_pc = ''.join(', T%d&& t%d' % (n+1, n+1) for n in range(0,arg_count))
%>
template <class Scheduler, class Env, ${typename_T_list_tc}void (*F)(${T_list})>
class FnClosure${arg_count} {
 public:
  static const typename ClosureRef<${T_list}>::VTable vtable;

 private:
  static void Schedule(void* env${fun_args_pc}) {
    Scheduler::Schedule([${t_list}](void*) { F(${t_list}); }, static_cast<Env*>(env));
  }
  static void UnsafeRun(void* env${fun_args_pc}) {
    Scheduler::UnsafeRun([${t_list}](void*) { F(${t_list}); }, static_cast<Env*>(env));
  }
};

template <class Scheduler, class Env, ${typename_T_list_tc}void (*F)(${T_list})>
const typename ClosureRef<${T_list}>::VTable FnClosure${arg_count}<Scheduler, Env, ${T_list_tc}F>::vtable = {
    Schedule, UnsafeRun};

template <class Scheduler, class C, ${typename_T_list_tc}void (C::*F)(${T_list})>
class MemClosure${arg_count} {
 public:
  static const typename ClosureRef<${T_list}>::VTable vtable;

 private:
  static void Schedule(void* env${fun_args_pc}) {
    Scheduler::Schedule([${t_list}](void* env) { (static_cast<C*>(env)->*F)(${t_list}); },
                        static_cast<C*>(env));
  }
  static void UnsafeRun(void* env${fun_args_pc}) {
    Scheduler::UnsafeRun([${t_list}](void* env) { (static_cast<C*>(env)->*F)(${t_list}); },
                   static_cast<C*>(env));
  }
};

template <class Scheduler, class C, ${typename_T_list_tc}void (C::*F)(${T_list})>
const typename ClosureRef<${T_list}>::VTable MemClosure${arg_count}<Scheduler, C, ${T_list_tc}F>::vtable = {
    Schedule, UnsafeRun};
% endfor

template <class Scheduler>
class MakesClosuresForScheduler {
 public:
% for arg_count in range(0, GENERATE_ARGS):
<%
  # _tc means 'trailing comma'
  # _pc means 'prefixed comma'
  typename_T_list_tc = ''.join('typename T%d, ' % (n+1) for n in range(0,arg_count))
  T_list = ', '.join('T%d' % (n+1) for n in range(0,arg_count))
  T_list_tc = ''.join('T%d, ' % (n+1) for n in range(0,arg_count))
  t_list = ', '.join('t%d' % (n+1) for n in range(0,arg_count))
  fun_args_pc = ''.join(', T%d&& t%d' % (n+1, n+1) for n in range(0,arg_count))
%>
  /// Construct a ClosureRef that calls a free function with ${arg_count} arguments. The optional env parameter defines an environment, and is required for schedulers that retrieve data from some environment (e.g. Combiner)
  template <${typename_T_list_tc}void (*F)(${T_list}), typename Env = std::nullptr_t>
  ClosureRef<${T_list}> MakeClosure(Env* env = nullptr) {
    return ClosureRef<${T_list}>(&closure_impl::FnClosure${arg_count}<Scheduler, Env, ${T_list_tc}F>::vtable,
                        env);
  }

  /// Construct a ClosureRef that calls a member function on class C with ${arg_count} arguments. The closure environment is assumed to be the instance pointer to C, and is required
  template <class C, ${typename_T_list_tc}void (C::*F)(${T_list})>
  ClosureRef<${T_list}> MakeClosure(C* p) {
    return ClosureRef<${T_list}>(&closure_impl::MemClosure${arg_count}<Scheduler, C, ${T_list_tc}F>::vtable, p);
  }
% endfor
};

}  // namespace closure_impl

//
// SCHEDULERS
//

class AcquiresNoLocks
    : public closure_impl::MakesClosuresForScheduler<AcquiresNoLocks> {
 public:
  template <class T, class F>
  static void Schedule(F&& f, T* env) {
    f(env);
  }
  template <class T, class F>
  static void UnsafeRun(F&& f, T* env) {
    f(env);
  }
};

// TODO(ctiller): move this into it's final place
#if 0
template <class F>
void QueueOnExecCtx(F&& f);

class RunInCurrentThread : public closure_impl::MakesClosuresForScheduler<RunInCurrentThread> {
 public:
  template <class T, class F>
  static void Schedule(F&& f, T* env) {
    QueueOnExecCtx([f, env]() { f(env); });
  }
  template <class T, class F>
  static void UnsafeRun(F&& f, T* env) {
    f(env);
  }
};

class RunInCombiner : public closure_impl::MakesClosuresForScheduler<RunInCombiner> {
 public:
  template <class T, class F>
  static void Schedule(F&& f, T* env) {
    env->combiner()->Schedule([f, env]() { f(env); });
  }
  template <class T, class F>
  static void UnsafeRun(F&& f, T* env) {
    env->combiner()->UnsafeRun([f, env]() { f(env); });
  }
};

// Dummy combiner lock impl

class Combiner {
 public:
  template <class F>
  void Schedule(F&& f);
  template <class F>
  void UnsafeRun(F&& f);
};

//
// TEST CODE
//

void PrintLine();
void PrintInt(int);

class Foo {
 public:
  void Callback();

  Combiner* combiner() { return &combiner_; }

 private:
  Combiner combiner_;
};

ClosureRef<> Hidden();

void test() {
  // simple closures around functions, member functions
  ClosureRef<> print_line = AcquiresNoLocks::MakeClosure<PrintLine>();
  ClosureRef<int> print_int = AcquiresNoLocks::MakeClosure<int, PrintInt>();
  Foo foo;
  ClosureRef<> foo_cb = AcquiresNoLocks::MakeClosure<Foo, &Foo::Callback>(&foo);

  print_line.UnsafeRun();
  print_int.UnsafeRun(42);
  foo_cb.UnsafeRun();

  // exec context test
  ClosureRef<> foo_cb_in_exec_ctx =
      RunInCurrentThread::MakeClosure<Foo, &Foo::Callback>(&foo);
  foo_cb_in_exec_ctx.Schedule();

  // combiner lock test - picks up combiner from Foo
  ClosureRef<> foo_cb_in_combiner =
      RunInCombiner::MakeClosure<Foo, &Foo::Callback>(&foo);
  foo_cb_in_combiner.Schedule();
  // can pass in a raw function too, but need to provide an environment
  // in this case something that provides a combiner() method
  ClosureRef<> print_line_in_combiner =
      RunInCombiner::MakeClosure<PrintLine>(&foo);
  print_line_in_combiner.Schedule();

  Hidden().UnsafeRun();

  // empty closure test
  ClosureRef<> empty;
  empty.UnsafeRun();
}
#endif

}  // namespace grpc_core

#endif /* GRPC_CORE_LIB_SUPPORT_CLOSURE_REF_H */
"""

import mako.template

text = mako.template.Template(_TEMPLATE).render()
print text
with open('src/core/lib/support/closure_ref.h', 'w') as f:
  f.write(text)
